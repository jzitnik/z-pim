% \iffalse
%
% Trademarks appear throughout this documentation without any trademark
% symbol, so you can't assume that a name is free. There is no intention
% of infringement; the usage is to the benefit of the trademark owner.
%
%
%  S O F T W A R E   L I C E N S E
% =================================
%
% The files lstkernel.dtx, lstaspects.dtx, listings2.ins, and all files
% generated from only these files are referred to as `the listings package'.
% lstlanguages.dtx and the files generated from that file are `language
% drivers'.
%
% The listings package version 2 is copyright 2008,2009 Carsten Heinz.
% It is based on prior versions of the package, which are copyright
% 1996--2004 Carsten Heinz and copyright 2006--2007 Brooks Moses for
% continued maintenance.
% The drivers are copyright 1997/1998/1999/2000/2001/2002/2003/2004/2006/
% 2007 any individual author listed in the driver files.
%
% The listings package and its drivers may be distributed and/or modified
% under the conditions of the LaTeX Project Public License, either version
% 1.3 of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2003/12/01 or later.
%
% The package has the LPPL maintenance status "maintained".
%
% The Current Maintainer is Carsten Heinz <cheinz@gmx.de>.
%
% end of software license
%
%
%<*driver>
% % \documentclass[a4paper]{ltxdoc}
% % \DisableCrossrefs
% % \OnlyDescription
% % 
% % \usepackage{lstdoc,textcomp}
% % \makeindex
% % 
% % \begin{document}
% %   \DocInput{lstkernel.dtx}
% %   \DocInput{lstaspects.dtx}
% % \end{document}
%</driver>
% \fi
%
%
% \part{Implementation}
%
%^^A \CheckSum{}
%
%
% \section{Overture}
%
%    \begin{macrocode}
%<*kernel>
%    \end{macrocode}
%
% \begin{macro}{\filedate}
% \begin{macro}{\fileversion}
% The following two definitions can be modified by a patch file.
%    \begin{macrocode}
\def\filedate{2009/12/31}
\def\fileversion{2.0beta}
%    \end{macrocode}
% If we don't run under \(\varepsilon\)-\LaTeX, we give an error message and abort
%  the loading.
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\@ifundefined{eTeXversion}
{\PackageError{Listings}{%
^^J***%
^^J*** Listings \fileversion\space requires e-LaTeX to run. Instead of `latex'
^^J*** or `pdflatex' try `elatex', `pdfelatex', `xelatex', or
^^J*** something similar to your command.
^^J***%
^^J*** The package will not be loaded.
^^J***\@gobble}\@ehc
\endinput}
{}
%    \end{macrocode}
% Who we will be at the end of this package---after patch loading.
%    \begin{macrocode}
\AtEndOfPackage{\ProvidesPackage{listings2}
             [\filedate\space\fileversion\space(Carsten Heinz)]}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@CheckVersion}
% \marg{required version}
% can be used by driver files to guarantee the correct version.
%    \begin{macrocode}
\def\lst@CheckVersion#1{\edef\reserved@a{#1}%
  \ifx\lst@version\reserved@a \expandafter\@gobble
                        \else \expandafter\@firstofone \fi}
%    \end{macrocode}
%    \begin{macrocode}
\let\lst@version\fileversion
%    \end{macrocode}
% Note that we don't save away a value possibly modified by a patch file.
% It's the original version defined above.
% \end{macro}
%
% \begin{macro}{\lst@InputCatcodes}
% We use the following catcodes for driver and kernel file loading.
%    \begin{macrocode}
\def\lst@InputCatcodes{%
  \makeatletter
  \catcode`\"=12\catcode`\:=12\catcode`\-=12%
  \catcode`\^^I=9\catcode`\^^L=9\catcode`\^^M=9%
  \catcode`\%=14\catcode`\~=\active\catcode`\^^@=\active}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@RestoreCatcodes}
% Since the kernel is not loaded inside a group, we need to restore all modified
%  catcodes.
% The catcode changes are taken from |\lst@InputCatcodes|.
%    \begin{macrocode}
\def\lst@RestoreCatcodes#1\catcode#2#3=#4{%
  \catcode#2\noexpand#3=\the\catcode#2#3%
  \ifnum#2#3=\z@\else \expandafter\lst@RestoreCatcodes \fi}
\edef\lst@RestoreCatcodes{%
  \noexpand\let\noexpand\lst@RestoreCatcodes\noexpand\@empty
  \noexpand\lccode`\noexpand\/`\noexpand\/%
  \expandafter\lst@RestoreCatcodes\lst@InputCatcodes}
%    \end{macrocode}
% Now we are ready for
%    \begin{macrocode}
\lst@InputCatcodes
\AtEndOfPackage{\lst@RestoreCatcodes}
%    \end{macrocode}
% \end{macro}
%
% \section{Package frameset}
%
% \begin{macro}{\@lst}
% is used to build control sequences and saves some memory.
%    \begin{macrocode}
\def\@lst{lst@}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Error and info messages}
%
% \begin{macro}{\lst@Error}
% Ditto, but used for error messages, of course.
%    \begin{macrocode}
\def\lst@Error{\PackageError{Listings}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@Info}
% \begin{macro}{\lstinfolevel}
% Shows messages if the level of the message is smaller than |\lst@infolevel|.
%    \begin{macrocode}
%<*info>
\def\lst@Info#1#2{\ifnum#1<\lstinfolevel\relax \typeout{listings2: #2}\fi}
\@ifundefined{lstinfolevel}{\let\lstinfolevel\z@}{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@GetAllocs}
% \begin{macro}{\lst@ReportAllocs}
% are used to show the allocated registers.
%    \begin{macrocode}
\def\lst@GetAllocs{%
  \edef\lst@allocs{%
    0\noexpand\count\the\count10,1\noexpand\dimen\the\count11,%
    2\noexpand\skip\the\count12,3\noexpand\muskip\the\count13,%
    4\noexpand\box\the\count14,5\noexpand\toks\the\count15,%
    6\noexpand\read\the\count16,7\noexpand\write\the\count17}}
\def\lst@ReportAllocs{%
  \lst@Info\tw@{Allocated registers:}\def\lst@temp{\@spaces none}%
  \expandafter\lst@ReportAllocs@\lst@allocs,\z@\relax\z@,}
\def\lst@ReportAllocs@#1#2#3,{%
  \ifx#2\relax
    \ifx\@empty\lst@temp\else \lst@Info\tw@{\lst@temp}\fi
  \else
    \@tempcnta\count1#1\relax \advance\@tempcnta -#3\relax
    \ifnum\@tempcnta=\z@\else
      \let\lst@temp\@empty
      \lst@Info\tw@{\@spaces\the\@tempcnta \string#2}%
    \fi
    \expandafter\lst@ReportAllocs@
  \fi}
%</info>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsection{Data macro manipulation}
%
% \begin{macro}{\lst@ProvideDef}
% \meta{control sequence}\meta{prefix}\meta{default}
% If the control sequence is not defined, it becomes equivalent to |#3| using
%  |#2| as the |\let| prefix.
%    \begin{macrocode}
\def\lst@ProvideDef#1#2#3{%
  \ifx#1\lst@undefined #2\let#1#3%
     \else\ifx#1\relax #2\let#1#3\fi\fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DefOther}
% \meta{control sequence}\marg{content}
%
% We use the fact that |\@onelevel@sanitize| produces catcode 12 characters
%  except for spaces.
% |\escapechar| is modified locally to suppress the output of an escape
%  character.
% Moreover we remove spaces via \LaTeX's |\zap@space|.
%    \begin{macrocode}
\def\lst@DefOther#1#2{%
  \begingroup
  \def#1{#2}\escapechar\m@ne \@onelevel@sanitize#1
  \expandafter\endgroup\expandafter
  \edef\expandafter#1\expandafter{\expandafter\zap@space#1 \@empty}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@NormedDef}
% \meta{control sequence}\marg{content}
% uses |\lowercase| and |\zap@space| on the content.
%    \begin{macrocode}
\def\lst@NormedDef#1#2{\lowercase{\edef#1{\zap@space#2 \@empty}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@NormedNameDef}
% \marg{name}\marg{content}
% Ditto, but also on the control sequence name.
% Moreover, it's a global definition.
%    \begin{macrocode}
\def\lst@NormedNameDef#1#2{%
  \lowercase{\expandafter
  \xdef\csname\zap@space#1 \@empty\endcsname{\zap@space#2 \@empty}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@AddTo}
% \begin{macro}{\lst@lAddTo}
% \begin{macro}{\lst@eAddTo}
% \begin{macro}{\lst@elAddTo}
% \meta{control sequence}\marg{content}
% adds material to the (global or local) definition.
% The |e|-versions expand the first token of \meta{content} first.
%    \begin{macrocode}
\long\def\lst@AddTo#1#2{\expandafter\gdef\expandafter#1\expandafter{#1#2}}
\def\lst@lAddTo#1#2{\expandafter\def\expandafter#1\expandafter{#1#2}}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@eAddTo#1#2{\expandafter\lst@AddTo\expandafter#1\expandafter{#2}}
\def\lst@elAddTo#1#2{\expandafter\lst@lAddTo\expandafter#1\expandafter{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@AddToAtTop}
% \meta{control sequence}\marg{content}
% expands the control sequence and put the content in front of it.
%    \begin{macrocode}
\def\lst@AddToAtTop#1{\expandafter\lst@AddToAtTop@\expandafter{#1}#1}
\long\def\lst@AddToAtTop@#1#2#3{\gdef#2{#3#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@AddToStackItem}
% \marg{material}
% is an easy application of |\lst@AddToAtTop|.
%    \begin{macrocode}
\def\lst@AddToStackItem{\lst@AddToAtTop\lst@stackitem}
\global\let\lst@stackitem\@empty
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@SaveToStackItem}
% \meta{control sequence}
%
% We expand the contents of |#1| behind |\def#1{| (and in front of |}|) and add
%  this to the stackitem
%    \begin{macrocode}
\def\lst@SaveToStackItem#1{%
  \expandafter\lst@AddToStackItem\expandafter
      {\expandafter\def\expandafter#1\expandafter{#1}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@Push}
% \meta{stack (control sequence)}
%
% We use a stack to manage a couple of things.
% Note that the content of the first |\lst@stackitem| is pushed and the second
%  is used as a terminator.
%    \begin{macrocode}
\def\lst@Push#1{%
  \expandafter\lst@AddToAtTop\expandafter#1\expandafter
                             {\lst@stackitem\lst@stackitem}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@Pop}
% \meta{stack (control sequence)}
%
% If the stack is empty, we gobble the following commands.
% Otherwise we adjust the stack contents and define the item.
%    \begin{macrocode}
\def\lst@Pop#1{%
  \ifx#1\@empty
    \global\let\lst@stackitem\@empty
    \expandafter\lst@GobbleNil
  \fi
  \expandafter\lst@Pop@\expandafter#1#1\@nil}
\def\lst@Pop@#1#2\lst@stackitem#3\@nil{\gdef#1{#3}\gdef\lst@stackitem{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@RemoveFromList}
% \meta{data macro}\meta{items (macro)}
%
% We  expand the second macro---the list of items to remove---and append the
%  terminator |\relax|.
%    \begin{macrocode}
\def\lst@RemoveFromList#1#2{%
  \expandafter\lst@RemoveFromList@\expandafter#1#2,\relax,}
%    \end{macrocode}
% `Replacing' the |\lst@RemoveFromList@| after |\fi| by |\lst@RemoveCommas|
%  terminates the loop here.
% Note: The |\@empty| after |#2| ensures that this macro also works with an
%  empty |#2|.
%    \begin{macrocode}
\def\lst@RemoveFromList@#1#2,{%
  \ifx\relax#2\@empty
    \expandafter\@firstoftwo\expandafter\lst@RemoveCommas
  \else
    \ifx\@empty#2\@empty\else
%    \end{macrocode}
% If the item is not empty, we define a temporary macro which removes all
%  appearances by replacing |,#2,| by a single comma.
%    \begin{macrocode}
      \def\lst@temp##1,#2,##2{%
        ##1%
        \ifx\@empty##2\@empty\else
            \expandafter\lst@temp\expandafter,%
        \fi ##2}%
      \edef#1{\expandafter\lst@temp\expandafter,#1,#2,\@empty}%
    \fi
  \fi
  \lst@RemoveFromList@#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@RemoveCommas}
% \meta{data macro}
% drops commas at the beginning and assigns the new value to |#1|.
%    \begin{macrocode}
\def\lst@RemoveCommas#1{\edef#1{\expandafter\lst@RC@#1\@empty}}
\def\lst@RC@#1{\ifx,#1\expandafter\lst@RC@ \else #1\fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ReplaceIn}
% \meta{data macro}\meta{item/replacement macro}
% is similar to |\lst@RemoveFromList|, except that \ldots
%    \begin{macrocode}
\def\lst@ReplaceIn#1#2{%
  \expandafter\lst@ReplaceIn@\expandafter#1#2\@nnil\@nnil}
%    \end{macrocode}
% we replace |#2| by |#3| instead of |,#2,| by a single comma.
%    \begin{macrocode}
\def\lst@ReplaceIn@#1#2#3{%
  \ifx\@nnil#3\relax
    \expandafter\@gobbletwo
  \else
    \def\lst@temp##1#2##2{%
      \ifx\@nnil##2%
        \lst@lAddTo#1{##1}\expandafter\@gobble
      \else
        \lst@lAddTo#1{##1#3}\expandafter\lst@temp
      \fi ##2}%
    \let\@tempa#1\let#1\@empty
    \expandafter\lst@temp\@tempa#2\@nnil
  \fi
  \lst@ReplaceIn@#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@RemoveDefFrom}
% \meta{data macro}\meta{control sequence}
% removes |\def#2{...}|.
%    \begin{macrocode}
\def\lst@RemoveDefFrom#1#2{%
  \def\lst@temp##1\def#2##2##3{%
    \lst@lAddTo#1{##1}%
    \ifx\@empty##3\else \expandafter\lst@temp \fi
    ##3}%
  \let\lst@arg#1\let#1\@empty
  \expandafter\lst@temp\lst@arg\def#2\@empty\@empty}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@IfEmptyIntersecion}
% \meta{list macro 1}\meta{list macro 2}\marg{then}\marg{else}
%    \begin{macrocode}
\def\lst@IfEmptyIntersection#1#2{%
  \bgroup \lst@true
  \lst@for#1\do{\lst@IfOneOf##1\relax#2{\lst@false\lst@forbreak}{}}%
  \lst@if \aftergroup\@firstoftwo \else \aftergroup\@secondoftwo \fi
  \egroup}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Flow of control}
%
% \begin{macro}{\lst@IfSubstring}
% \marg{chars}\meta{data macro}\marg{then}\marg{else}
%
% The temporary macro checks for the substring.
%    \begin{macrocode}
\def\lst@IfSubstring#1#2{%
  \def\lst@temp##1#1##2##3\relax{%
    \ifx \@empty##2\expandafter\@secondoftwo
             \else \expandafter\@firstoftwo \fi}%
  \expandafter\lst@temp#2#1\@empty\relax}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@IfOneOf}
% \marg{item (chars)}\meta{data macro}\marg{then}\marg{else}
%
% Ditto with commas as delimiters.
%    \begin{macrocode}
\def\lst@IfOneOf#1\relax#2{%
  \def\lst@temp##1,#1,##2##3\relax{%
    \ifx \@empty##2\expandafter\@secondoftwo
             \else \expandafter\@firstoftwo \fi}%
  \expandafter\lst@temp\expandafter,#2,#1,\@empty\relax}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@IfNextChars}
% \marg{chars}\marg{then}\marg{else}
%
% We save arguments and start a loop.
%    \begin{macrocode}
\def\lst@IfNextChars#1#2#3{%
  \def\reserved@a{#2}\def\reserved@b{#3}\let\lst@eaten\@empty
  \lst@IfNextChars@#1\relax}
\def\lst@IfNextChars@#1#2\relax#3{%
  \lst@lAddTo\lst@eaten{#3}%
%    \end{macrocode}
% If the characters have the same code, we call |\reserved@a| or continue the
%  test.
% Otherwise we call |\reserved@b|.
%    \begin{macrocode}
  \ifnum`#1=`#3%
    \ifx\@empty#2\@empty \let\lst@next\reserved@a
                   \else \def\lst@next{\lst@IfNextChars@#2\relax}\fi
    \expandafter\lst@next
  \else
    \expandafter\reserved@b
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@IfNextCharEOL}
% \marg{then}\marg{else}
%
% Like in |\lst@IfNextChars| we test the character code of |#1|.
%    \begin{macrocode}
\def\lst@IfNextCharEOL#1#2#3{%
  \let\lst@next\@firstoftwo
  \ifnum`#3=\z@\else \ifnum`#3=10\else \ifnum`#3=\active\else
    \let\lst@next\@secondoftwo
  \fi \fi \fi
  \lst@next{#1}{#2}#3}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@for}
% \marg{list or macro}|\do|\marg{one-parameter-text}
%
% A for-loop with expansion of the loop-variable.
%    \begin{macrocode}
\def\lst@for#1\do#2{%
  \def\lst@forbody##1,{%
    \ifx \@nnil##1\expandafter\@gobbletwo
             \else\expandafter\@firstofone \fi
    {#2}\lst@forbody}%
  \ifx\@empty#1\@empty\else
    \expandafter\lst@forbody#1,\@nnil,%
  \fi}
%    \end{macrocode}
% \begin{remark}{Old definition}
% Hendri Adriaens suggested a much improved definition of Listings' 1.3
%  |\lst@for|, which made it into version 1.4:
% \begin{verbatim}
% \def\lst@for#1\do#2{%
%   \def\lst@forbody##1{#2}%
%   \def\@tempa{#1}%
%   \ifx\@tempa\@empty\else\expandafter\lst@f@r#1,\@nil,\fi}
% \def\lst@f@r#1,{%
%   \def\@tempa{#1}%
%   \ifx\@tempa\@nnil\else\lst@forbody{#1}\expandafter\lst@f@r\fi}\end{verbatim}
% A |\lst@forbreak| for this loop could be
% \begin{verbatim}
% \def\lst@forbreak{\def\lst@forbody##1\@nil,{\fi}}\end{verbatim}
% \end{remark}
% \end{macro}
%
% \begin{macro}{\lst@forbreak}
% Escapes from the loop by redefining |\lst@forbody| to gobble all material up
%  to |\@nnil,|.
%    \begin{macrocode}
\def\lst@forbreak{\def\lst@forbody##1\@nnil,{}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@if}
% \begin{macro}{\lst@true}
% \begin{macro}{\lst@false}
% A general |\if| for temporary use.
%    \begin{macrocode}
\def\lst@true{\let\lst@if\iftrue}
\def\lst@false{\let\lst@if\iffalse}
\lst@false
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@gobblethree}
% is defined if and only if undefined.
%    \begin{macrocode}
\providecommand*\@gobblethree[3]{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@GobbleNil}
%    \begin{macrocode}
\def\lst@GobbleNil#1\@nil{}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Driver file handling}
%
% Language, style and format definitions as well as the kernel plugins (the
%  `aspects') are loaded from driver files.
% These files can be loaded partially and on demand.
% In addition to |\lst@BeginAspect| and |\lst@EndAspect| (both described in
%  section \ref{dHowToDefineLstAspects}) this section `exports' the following
%  macros.
% \begin{syntax}
% \item[2.0,,new] |\lst@DefDriverFiles|\meta{file list macro}\marg{file list}
%
%   puts each existent file into \meta{file list macro}.
%   Afterwards that macro can be used as argument to |\lst@SetDriver|.
%
% \item[,,changed] |\lst@SetDriverAlias|\marg{class}[\oarg{sub}]\marg{main}\oarg{alias sub}\marg{alias main}
%
%   defines a redirection either for \meta{main} in \meta{class} (e.g.~|cpp| in
%    the class of languages) or for a specific \meta{sub} feature of \meta{main}
%    (e.g.~a specific dialect).
%   Note that the second last argument is \emph{not} optional.
%
% \item[,,changed] |\lst@SetDriverDefault|\marg{class}\oarg{sub}\marg{main}
%
%   defines \meta{sub} to be default for \meta{main} in \meta{class} (e.g.~a
%    default dialect of a language).
%
% \item[0.21,,changed] |\lst@SetDriver|\marg{class}\marg{driver list}\marg{file list (macro)}\marg{pre}\marg{post}
%
%   was previously named |\lst@LAS| since it is used \keyname{language} and
%   \keyname{style} keys to load a driver on demand and select it.
%   An error message is issued if the driver is not loadable.
%   Otherwise \meta{pre}, the driver definition, and \meta{post} are executed.
%
% \item[0.20,,changed] |\lst@DefDriver|\meta{\alternative{\textbackslash iftrue,false}}\marg{class}\meta{set macro}\syntaxnewline
%       [\oarg{sub}]\marg{main}[\oarg{base sub}\marg{base main}]\syntaxnewline
%       \marg{feature definition}[\oarg{required aspects}]
%
%   The boolean value determines whether the driver is defined for sure.
%   For example, |\lst@definelanguage| uses |\iffalse| and the driver is defined
%    only if it has been requested.
%   The command |\lstdefinelanguage| makes use of this definition by
%    |\lst@DefDriver\iftrue{language}\lstsetup|.
%   Since languages use usual key\(=\)value lists, \meta{set macro} equals
%    |\lstsetup|.
%   The other parameters are provided by the user and match exactly the
%    parameters for language definitions.
%
% \item[0.20] |\lst@RequireAspects|\marg{comma separated list of aspect names}
%
%   loads the specified aspects if they are not already loaded.
%
% \item[2.0,,new] |\lst@RequireDrivers|\marg{class}\marg{driver list}\marg{file list (macro)}
%
%   loads the drivers from the given files.
%   If a driver is not loadable, an error message is given.
% \end{syntax}
%
%
% \subsubsection{Aliases}
%
% \begin{macro}{\lst@SetDriverRedirect}
% \meta{data macro}\marg{source}\marg{target}
% puts an item for the redirection into the macro.
% If \meta{target} is empty or |[]|, the redirection is deleted.
%
% First we delete previous data in |#1| for \meta{source}.
% Then we insert the new item \meta{source}|>|\meta{target} if necessary.
%    \begin{macrocode}
\def\lst@SetDriverRedirect#1#2#3{%
  \lst@RemoveDriverRedirect#1{#2}%
  \def\lst@temp{[]}\def\lst@arg{#3}
  \ifx\lst@arg\@empty\else \ifx\lst@arg\lst@temp\else
    \lst@NormedDef\lst@arg{,#2>#3}%
    \lst@eAddTo#1\lst@arg
  \fi \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@RemoveDriverRedirect}
% \meta{data macro}\marg{source}
% removes any redirections for the source in the data macro.
%
% We ensure the existence of the data macro, \ldots
%    \begin{macrocode}
\def\lst@RemoveDriverRedirect#1#2{%
  \lst@ProvideDef#1\global\@empty
  \lst@NormedDef\lst@arg{#2}%
  \expandafter\lst@RemoveDriverRedirect@\expandafter{\lst@arg}#1}
\def\lst@RemoveDriverRedirect@#1#2{%
%    \end{macrocode}
% define an expandable macro to detect \meta{source}|>|, and define new the data
%  macro without such redirections.
%    \begin{macrocode}
  \def\lst@temp##1,#1>##2,##3{%
    ##1%
    \ifx##3\@nnil\expandafter\@gobbletwo \else \expandafter\lst@temp \fi
    ,##3}%
  \xdef#2{\expandafter\lst@temp#2,#1>,\@nnil}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@GetDriverRedirect}
% \meta{data macro}\marg{source}
% puts the redirection into |\lst@redirect| (or the source itself if there is no
%  redirection).
%
% We (|\edef| and) normalize the source.
%    \begin{macrocode}
\def\lst@GetDriverRedirect#1#2{%
  \edef\lst@temp{\noexpand\lst@NormedDef\noexpand\lst@temp{#2}}%
  \lst@temp
  \expandafter\lst@GetDriverRedirect@\expandafter{\lst@temp}#1}
%    \end{macrocode}
% The temporary macro defines |\lst@redirect| and sets |\lst@if| true if and
%  only if we've found an item.
%    \begin{macrocode}
\def\lst@GetDriverRedirect@#1#2{%
  \def\lst@temp##1,#1>##2,##3##4\@nil{%
    \ifx##3\@nnil \lst@false \def\lst@redirect{#1}%
            \else \lst@true \def\lst@redirect{##2}\fi}%
  \expandafter\lst@temp#2,#1>,\@nnil\@nil
%    \end{macrocode}
% We look for another redirection if necessary by calling this submacro.
%    \begin{macrocode}
  \lst@if
    \edef\lst@temp{\noexpand\lst@GetDriverRedirect@{\lst@redirect}%
                                                   \noexpand#2}%
    \expandafter\lst@temp
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@SetDriverAlias}
% \marg{class}[\oarg{sub}]\marg{main}\oarg{alias sub}\marg{alias main}
%
% We build a \meta{data macro} and either set a redirection for a main feature
%  (a language family) or a sub-feature (a language dialect).
%    \begin{macrocode}
\def\lst@SetDriverAlias#1{%
  \expandafter\lst@SetAlias@\csname\@lst#1alias\endcsname}
\def\lst@SetAlias@#1{\@ifnextchar[{\lst@SetAlias@s #1}%
                                  {\lst@SetAlias@m #1}}%
\def\lst@SetAlias@s#1[#2]#3[#4]#5{\lst@SetDriverRedirect#1{[#2]#3}{[#4]#5}}
\def\lst@SetAlias@m#1#2#3{\lst@SetDriverRedirect#1{#2}{#3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@SetDriverDefault}
% \marg{class}\oarg{sub}\marg{main}
%
% Here we set a redirect for |[]|\meta{main} to |[|\meta{sub}|]|\meta{main} if
%  \meta{sub} is not empty.
% Otherwise we delete a default.
%    \begin{macrocode}
\def\lst@SetDriverDefault#1{%
  \expandafter\lst@SetDriverDefault@\csname\@lst#1alias\endcsname}
\def\lst@SetDriverDefault@#1#2{%
  \lstKV@OArg[]{#2}{\ifx\@empty##1\@empty
                      \lst@RemoveDriverRedirect#1{[]##2}%
                    \else
                      \lst@SetDriverRedirect#1{[]##2}{[##1]##2}%
                    \fi}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@GetDriverAlias}
% \marg{class}|{|\oarg{sub}\meta{main}|}|
% points |\lst@redirect| to the alias of \oarg{sub}\meta{main} taking all kinds
%  of redirections into account.
%
% We build the data macro and extract the parameters.
%    \begin{macrocode}
\def\lst@GetDriverAlias#1{%
  \expandafter\lst@GetDriverAlias@\csname\@lst#1alias\endcsname}
\def\lst@GetDriverAlias@#1#2{%
  \lst@ProvideDef#1\global\@empty
  \lstKV@OArg[]{#2}{\lst@NormedDef\lst@arg{##1}%
                    \lst@NormedDef\lst@redirect{##2}}%
%    \end{macrocode}
% We check for driver aliases (by not specifying |[|\ldots|]|) and then
%  |[|\meta{sub}|]|\meta{main}-redirections (in particular driver defaults).
%    \begin{macrocode}
  \lst@GetDriverRedirect#1\lst@redirect
  \lst@GetDriverRedirect#1{[\lst@arg]\lst@redirect}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Driver definitions}
%
% \begin{macro}{\lst@DefDriver}
% |#1|\(=\)|\iftrue| means that the driver will be defined; otherwise it depends
%  on whether the driver is required (e.g.~has been requested).
% All the rest just reads the (optional) arguments of the command.
%    \begin{macrocode}
\def\lst@DefDriver#1#2#3{%
  \let\lst@if#1%
  \@ifnextchar[{\lst@DefDriver@{#2}{#3}}%
               {\lst@DefDriver@{#2}{#3}[]}}
\def\lst@DefDriver@#1#2[#3]#4{%
  \@ifnextchar[{\lst@DefDriver@@{#1}{#2}[#3]{#4}}%
               {\lst@DefDriver@@{#1}{#2}[#3]{#4}[]{}}}
%    \end{macrocode}
% We have to adjust catcodes to read the contents of the driver.
% Note that |{#1}{#2}[#3]{#4}| are arguments to |\lst@DefDriver@Def|, which are
%  preceded by |\iftrue| or |\iffalse| (not) to define the driver.
% This is inserted depending on whether |[#3]#4| is in the list of required
%  items.
%    \begin{macrocode}
\def\lst@DefDriver@@#1#2[#3]#4{%
  \lst@NormedDef\lst@arg{[#3]#4}%
  \begingroup \lst@setcatcodes
  \expandafter\lst@IfOneOf\lst@arg\relax \lst@require
    {\lst@DefDriver@Def\iftrue}%
    {\lst@DefDriver@Def\lst@if}%
  {#1}{#2}[#3]{#4}}
\def\lst@DefDriver@Def#1#2#3[#4]#5[#6]#7#8{%
  \endgroup
%    \end{macrocode}
% Now we define the driver if necessary.
% First the item is moved from |\lst@require| to |\lst@loaded|.
%    \begin{macrocode}
  #1% iftrue|false
    \edef\lst@loaded{\lst@loaded,\lst@arg}%
    \lst@RemoveFromList\lst@require\lst@arg
%    \end{macrocode}
% We may need to insert \oarg{sub}\marg{feature} and request that subfeature.
%    \begin{macrocode}
    \ifx\@empty#6#7\@empty
      \def\lst@next{\lst@DefDriver@Def@#3{}}%
    \else
      \lst@GetDriverAlias{#2}{[#6]#7}%
      \@ifundefined{lst#2@\lst@redirect}%
        {\edef\lst@require{\lst@require,\lst@redirect}}{}%
      \def\lst@next{\lst@DefDriver@Def@#3{also#2=[#6]#7,}}%
    \fi
%    \end{macrocode}
% Determine the control sequence name in which to store the language or style data.
%    \begin{macrocode}
    \lst@NormedDef\lst@arg{lst#2@[#4]#5}%
%<*info>
    \lst@Info\@ne{storing #2 `[#4]#5' in
                  \expandafter\string\csname\lst@arg\endcsname}%
%</info>
    \expandafter\lst@next
  \else
    \expandafter\@gobble
  \fi
%    \end{macrocode}
% The following argument is read either by |\lst@DefDriver@Def@| or by
%  |\@gobble|.
%    \begin{macrocode}
  {#8}%
%    \end{macrocode}
% Eventually comes the optional aspect argument.
% We read it and load the aspects immediately or request them.
% |\lst@LoadRequiredCheck| checks whether all required items has been loaded and
%  possibly ends the input of the driver file.
%    \begin{macrocode}
  \@ifnextchar[{\lst@DefDriver@Aspects#1}\lst@LoadRequiredCheck}
\def\lst@DefDriver@Aspects#1[#2]{%
  \ifx\@empty#2\@empty\else
    \lst@if
      \lstloadaspects{#2}%
    \else
      #1% iftrue|false
        \lst@NormedDef\lst@temp{#2}%
        \xdef\lst@loadaspects{\lst@loadaspects,\lst@temp}%
      \fi
    \fi
  \fi
  \lst@LoadRequiredCheck}
%    \end{macrocode}
% The actual definition is quite short:
%    \begin{macrocode}
\def\lst@DefDriver@Def@#1#2#3{\global\@namedef{\lst@arg}{#1{#2#3}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@BeginAspect}
% Still a straight-forward implementation:
%    \begin{macrocode}
\newcommand*\lst@BeginAspect[2][]{%
  \ifx \@empty#2\@empty
    \expandafter\lst@GobbleAspect
  \else
%    \end{macrocode}
% If \meta{aspect name} is not empty, there are certain other conditions not to
%  define the aspect.
% Note that we request the base aspect if we have a nonempty subaspect.
%    \begin{macrocode}
    \lst@NormedDef\lst@arg{#2}%
    \lst@IfEmptyIntersection\lst@arg\lst@require{\lst@false}{\lst@true}%
    \lst@if
      \lst@RemoveFromList\lst@require\lst@arg
      \lst@for\lst@arg\do{\lstKV@OArg[]{##1}%
          {\begingroup
           \ifx\@empty####1\@empty\lst@RequireAspects{#1}%
                            \else \lst@RequireAspects{#1,####2}\fi
           \global\let\@gtempa\lst@require
           \endgroup}%
          \let\lst@require\@gtempa
          \lst@if \def\lst@curraspect{##1}\fi
          \lst@forbreak}%
    \fi
%    \end{macrocode}
% This aspects might have been loaded by |\lst@RequireAspects| above.
% So we check the current aspect against the loaded aspects.
%    \begin{macrocode}
    \lst@if
      \expandafter\lst@IfOneOf\lst@curraspect\relax\lst@loadedaspects
          {\lst@false}{}%
    \fi
    \lst@if
      \let\lst@next\@empty
      \edef\lst@loaded{\lst@loaded,\lst@curraspect}%
      \xdef\lst@loadedaspects{\lst@loadedaspects,\lst@curraspect}%
%    \end{macrocode}
% We might log the aspect name and get the current allocations.
%    \begin{macrocode}
%<*info>
      \lst@Info\@ne{defining aspect `\lst@curraspect'}\lst@GetAllocs
%</info>
%    \end{macrocode}
%    \begin{macrocode}
    \else
      \let\lst@next\lst@GobbleAspect
    \fi
    \expandafter\lst@next
  \fi}
%    \end{macrocode}
% The following macro drops all code up to the next |\lst@EndAspect|.
%    \begin{macrocode}
\long\def\lst@GobbleAspect#1\lst@EndAspect{\let\lst@curraspect\@empty}
%    \end{macrocode}
%    \begin{macrocode}
\global\let\lst@loadedaspects\@empty
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@EndAspect}
% finishes an aspect definition by applying configuration and a possible patch,
%  which both get undefined afterwards.
%    \begin{macrocode}
\def\lst@EndAspect{%
  \ifcsname lstconfig@\lst@curraspect\endcsname
    \csname lstconfig@\lst@curraspect\endcsname
    \global\expandafter\let\csname lstconfig@\lst@curraspect\endcsname
                           \lst@undefined
  \fi
  \ifcsname lstpatch@\lst@curraspect\endcsname
    \csname lstpatch@\lst@curraspect\endcsname
    \global\expandafter\let\csname lstpatch@\lst@curraspect\endcsname
                           \lst@undefined
  \fi
%<*info>
  \lst@ReportAllocs
  \lst@Info\@ne{Remaining aspects:}%
  \lst@Info\@ne{\@spaces \lst@require}%
%</info>
  \let\lst@curraspect\@empty
  \lst@LoadRequiredCheck}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@UserCommand}
% is equivalent to |\gdef|.
% It's just here to distinguish user commands and internal definitions.
% If information logging is on, it prints out the defined command name.
%    \begin{macrocode}
\let\lst@UserCommand\gdef
%<*info>
\def\lst@UserCommand#1{\lst@Info\tw@{defining command \string#1,}\gdef#1}
%</info>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@Key}
% The command simply defines the key.
% But we must take care of an optional parameter and the initialization argument
%  |#2|.
%    \begin{macrocode}
\def\lst@Key#1#2{%
%<*info>
  \lst@Info\tw@{defining key #1}%
%</info>
  \begingroup
  \def\lst@temp{\lst@Key@{#1}{#2}}%
  \@ifnextchar[{\lstKV@def{#1}{#2}}%
               {\afterassignment\lst@temp
                \global\@namedef{KV@\@lst#1}####1}}
%    \end{macrocode}
% Now comes a renamed and modified copy from a \packagename{keyval} macro since
%  we need global key definitions.
%    \begin{macrocode}
\def\lstKV@def#1#2[#3]{%
  \global\@namedef{KV@\@lst#1@default\expandafter}\expandafter
      {\csname KV@\@lst#1\endcsname{#3}}%
  \afterassignment\lst@temp
  \global\@namedef{KV@\@lst#1}##1}
%    \end{macrocode}
% We initialize the key if the first token of |#2| is not |\relax|.
%    \begin{macrocode}
\def\lst@Key@#1#2{%
  \ifx\relax#2\@empty\else
    \globaldefs\@ne
    \csname KV@\@lst#1\endcsname{#2}%
  \fi
  \endgroup}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@AddToHook}
% We define a previously unknown hook to be empty and add the content.
%    \begin{macrocode}
\long\def\lst@AddToHook#1{%
  \@ifundefined{lsthk@#1}{%
%<*info>
    \lst@Info\tw@{installing new hook `#1'}%
%</info>
    \expandafter\gdef\csname lsthk@#1\endcsname{}}{}%
  \expandafter\lst@AddTo\csname lsthk@#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@UseHook}
% just builds the control sequence.
%    \begin{macrocode}
\def\lst@UseHook#1{\csname lsthk@#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Driver loading}
%
% \begin{macro}{\lst@DefDriverFiles}
% We iterate through the list and add each existent file to the macro.
%    \begin{macrocode}
\def\lst@DefDriverFiles#1#2{%
  \let\lst@arg\@empty
  \lst@for #2\do {\IfFileExists{##1}{\edef\lst@arg{\lst@arg,##1}}{}}%
  \lst@RemoveCommas\lst@arg
  \global\let#1\lst@arg}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{aspectfiles}
% \begin{macro}{\lstaspectfiles}
% The key to set the macro.
%    \begin{macrocode}
\lst@Key{aspectfiles}\relax{\lst@DefDriverFiles\lstaspectfiles{#1}}
%    \end{macrocode}
% If |\lstaspectfiles| is undefined yet, we provide standard files.
%    \begin{macrocode}
\@ifundefined{lstaspectfiles}
{\KV@lst@aspectfiles{lstaspects0.sty,lstaspects.sty}}
{\KV@lst@aspectfiles\lstaspectfiles}
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
%
% \begin{macro}{\lst@require}
% \begin{macro}{\lst@loaded}
% These definitions contain the list of required respectively just loaded
%  drivers.
%    \begin{macrocode}
\let\lst@require\@empty
\let\lst@loaded\@empty
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@RequireAspects}
% By default the success indicator |\lst@if| is set true.
%    \begin{macrocode}
\def\lst@RequireAspects#1{%
  \lst@true
  \ifx\@empty#1\@empty\else
%    \end{macrocode}
% Each nonempty item is added to |\lst@require| if the aspect isn't loaded yet.
% |\lst@if| gets true if and only if we've added an item to the require-list.
%    \begin{macrocode}
    \lst@false
    \edef\lst@arg{\expandafter\zap@space#1 \@empty}%
    \lst@for\lst@arg\do{%
      \ifx\@empty##1\@empty\else
        \lst@IfOneOf##1\relax\lst@loadedaspects
          {}{\edef\lst@require{\lst@require,##1}%
             \lst@true}%
      \fi}%
%    \end{macrocode}
% If items were added, they need to be loaded immediately.
% Otherwise we indicate succuss.
%    \begin{macrocode}
    \lst@if \lst@LoadRequired{aspects}\lstaspectfiles
      \else \lst@true \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{loadaspects}
% \begin{macro}{\lstloadaspects}
% Synonyms for |\lst@RequireAspects|
%    \begin{macrocode}
\lst@Key{loadaspects}\relax{\lst@RequireAspects{#1}}
\let\lstloadaspects\lst@RequireAspects
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
%
% \begin{macro}{\lst@RequireDrivers}
% This is almost like |\lst@RequireAspects|, but
%    \begin{macrocode}
\def\lst@RequireDrivers#1#2#3{%
  \ifx\@empty#1\@empty\else
%    \end{macrocode}
% instead of |\lst@loadeaspects| we test for the existence of
%  |\lst|\meta{class}|@|\meta{item}.
%    \begin{macrocode}
    \lst@false
    \edef\lst@arg{\expandafter\zap@space#2 \@empty}%
    \lst@for\lst@arg\do{%
      \ifx\@empty##1\@empty\else
        \lst@GetDriverAlias{#1}{##1}%
        \@ifundefined{lst#1@\lst@redirect}%
          {\edef\lst@require{\lst@require,\lst@redirect}%
           \lst@true}%
          {}%
      \fi}%
%    \end{macrocode}
%    \begin{macrocode}
    \lst@if \lst@LoadRequired{#1}#3\fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@SetDriver}
% If the item is not empty and the feature is undefined yet, we try to load it.
%    \begin{macrocode}
\def\lst@SetDriver#1#2#3#4#5{%
  \lst@GetDriverAlias{#1}{#2}%
  \@ifundefined{lst#1@\lst@redirect}%
  {\begingroup
   \let\lst@require\lst@redirect
   \lst@LoadRequired{#1s}{#3}%
   \endgroup}{}%
%    \end{macrocode}
% If the feature is (still) undefined,  we give an error message.
% Otherwise we insert pre/post commands and activate the feature.
%    \begin{macrocode}
  \@ifundefined{lst#1@\lst@redirect}%
  {\lst@Error{The #1 \lst@redirect\space is not loadable.}\@ehc}%
  {#4\csname lst#1@\lst@redirect\endcsname #5}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@LoadRequired}
% By default |\lst@LoadRequiredCheck| is empty and called at the end of each
%  driver definition, but here it will end the input of a driver file
%  prematurely if there are no more required items.
% For this we change the catcodes of group braces and EOL and call
%  |\lst@LoadRequiredStop|.
% See below for some more explanation.
%    \begin{macrocode}
\def\lst@LoadRequired#1#2{%
  \begingroup
%<*info>
  \lst@Info\z@{trying to load the following #1 from #2}%
  \lst@Info\z@{\@spaces \lst@require}
%</info>
  \lst@InputCatcodes \let\lst@loaded\relax
  \def\lst@LoadRequiredCheck{%
    \ifx\@empty\lst@require
      \begingroup \catcode`\{9\catcode`\}9\catcode`\^^M\active
      \expandafter\lst@LoadRequiredStop
    \fi}%
%    \end{macrocode}
%    \begin{macrocode}
  \global\let\lst@loadaspects\@empty
  \lst@LoadRequired@{#2}%
%<*info>
  \ifx\lst@require\@empty\else
    \lst@Info\z@{couldn't load \lst@require}%
  \fi
%</info>
%    \end{macrocode}
% If some items couldn't be loaded, we issue an error and call |\lst@false|
%  (after closing the group) to indicate the error.
%    \begin{macrocode}
  \ifx\lst@require\@empty\else
    \lst@Error{Couldn't load all requested #1}%
    {The following #1 weren't loadable:\MessageBreak
     \@spaces\lst@require\MessageBreak
     This may cause errors in the sequel.}%
     \aftergroup\lst@false
  \fi
%    \end{macrocode}
% We load aspects possibly requested while loading the items.
%    \begin{macrocode}
  \ifx\lst@loadaspects\@empty\else
    \let\lst@require\@empty
    \lst@RequireAspects\lst@loadaspects
    \global\let\lst@loadaspects\@empty
  \fi
  \endgroup
  \let\lst@require\@empty}
%    \end{macrocode}
%    \begin{macrocode}
\global\let\lst@loadaspects\@empty
%    \end{macrocode}
% If nothing needs to be loaded or nothing more could be loaded, there's nothing
%  to do.
% Otherwise (if both |\lst@require| and |\lst@loaded| are nonempty) we iterate
%  through the given files and input them.
%    \begin{macrocode}
\def\lst@LoadRequired@#1{%
  \ifx\lst@require\@empty\else \ifx\lst@loaded\@empty\else
    \let\lst@loaded\@empty
    \lst@for{#1}\do{\InputIfFileExists{##1}{}{}%
                    \ifx\lst@require\@empty \lst@forbreak \fi}%
%    \end{macrocode}
% We call this macro by tail recursion to load features requested by the loaded
%  features.
%    \begin{macrocode}
    \def\lst@next{\lst@LoadRequired@{#1}}%
    \expandafter\expandafter\expandafter\lst@next
  \fi \fi}
%    \end{macrocode}
% Now we come to stopping the input of a driver file prematurely.
% Unfortunately, we can't just say |\endinput|.
% As a counterexample try
% \begin{verbatim}
%  \begin{filecontents}{texsub.tex}
%  \endinput You can read this in the output file.
%  \end{filecontents}
%
%  \documentclass{minimal}
%  \begin{document}
%    \input{texsub}
%  \end{document}\end{verbatim}
% Thus we changed some catcodes above (from which only EOL was necessary),
%  gobble the line up to the now active EOL and end the input.
% Note that the catcode changes are made inside a group.
%    \begin{macrocode}
\begingroup \lccode`\~=`\^^M\lowercase{\endgroup
\def\lst@LoadRequiredStop#1~}{\endgroup\endinput}%
%    \end{macrocode}
%    \begin{macrocode}
\let\lst@LoadRequiredCheck\@empty
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Interface to (\textsf{x})\textsf{keyval}}
%
% Don't wonder about the global definitions inside the macros here.
% |\lst@Key| might set |\globaldefs| to one and possibly call one of the macros.
% So definitions are sometimes globally anyway.
%
% \begin{macro}{\lstKV@OArg}
% We define the temporary macro |\@gtempa| and insert default argument if
%  necessary.
%    \begin{macrocode}
\def\lstKV@OArg[#1]#2#3{\gdef\@gtempa[##1]##2{#3}\lstKV@OArg@{#1}#2\@}
\def\lstKV@OArg@#1{\@ifnextchar[\lstKV@OArg@@{\lstKV@OArg@@[#1]}}
\def\lstKV@OArg@@[#1]#2\@{\@gtempa[#1]{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstKV@XOArg}
% Here we assign the third argument to |\@gtempa| since it is a macro definition
%  and not a replacement text.
% Moreover, we set |\lst@if| depending on whether there is a star in front.
%    \begin{macrocode}
\def\lstKV@XOArg[#1]#2#3{%
  \global\let\@gtempa#3%
  \@ifstar{\lst@false\lstKV@OArg@{#1}}%
          {\lst@true \lstKV@OArg@{#1}}#2\@}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstKV@SetIf}
% We simply test the lower case first character of the expansion of |#1|.
%    \begin{macrocode}
\def\lstKV@SetIf#1{\expandafter\lstKV@SetIf@#1\relax}%
\def\lstKV@SetIf@#1#2\relax#3{\lowercase{\expandafter
  \let\expandafter#3\csname if\ifx #1t}tru\else fals\fi e\endcsname}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstKV@SwitchCases}
% is implemented as a substring test.
%    \begin{macrocode}
\def\lstKV@SwitchCases#1#2#3{%
  \def\@gtempa##1\\#1&##2\\##3##4\@nil{\ifx\@empty##3#3\else ##2\fi}%
  \@gtempa\\#2\\#1&\\\@empty\@nil}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstKV@CountStars}
% stores the code to be executed later and counts the stars.
%    \begin{macrocode}
\def\lstKV@CountStars#1{\def\lst@next{#1}\@tempcntb\z@ \lstKV@CountStars@}
\def\lstKV@CountStars@{%
  \@ifstar{\advance\@tempcntb\@ne \lstKV@CountStars@}\lst@next}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstKV@ReadOArgs}
% We read optional stars, define the operation after reading the optional
%  arguments, and start the loop.
% Reaching the end of the macro list we gobble the |\@ifnextchar| test, but
%  leave |\lst@next| untouched.
%    \begin{macrocode}
\def\lstKV@ReadOArgs#1#2{%
  \lstKV@CountStars{\def\lst@next{#2}\lstKV@ReadOArgs@l#1\@nil}}
\def\lstKV@ReadOArgs@l#1#2\@nil[#3]{%
  \def#1{#3}%
  \ifx\relax#2\relax \expandafter\@gobblethree \fi
  \@ifnextchar[{\lstKV@ReadOArgs@l#2\@nil}%
               \lst@next}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstKV@ReadArgs}
% The loop reads the first macro name |##1| and assigns the replacement text
%  |##3|.
%    \begin{macrocode}
\def\lstKV@ReadArgs#1#2#3{%
  \gdef\lstKV@ReadArgs@l##1##2\relax##3#1{%
    \def##1{##3}%
%    \end{macrocode}
% The user hasn't provided enough arguments to fill all necessary macros if
%  |##1| equals |\@nnil|---i.e.~|##3| is |\@nil|.
% So we empty |##1| and either finish this macro (since |##2| is empty and
%  we've reached the end of the macro list) or we continue.
%    \begin{macrocode}
    \ifx ##1\@nnil
      \let##1\@empty
      \ifx\relax##2\relax
        \global\let\@gtempa\@empty
      \else
        \gdef\@gtempa{\lstKV@ReadArgs@l##2\relax\@nil#1}%
      \fi
    \else
%    \end{macrocode}
% Otherwise we do the same, but we need different definitions.
% We either gobble any remaining user provided arguments or we continue.
%    \begin{macrocode}
      \ifx\relax##2\relax
        \gdef\@gtempa####1\@nil#1{}%
      \else
        \gdef\@gtempa{\lstKV@ReadArgs@l##2\relax}%
      \fi
    \fi
    \@gtempa}
  \lstKV@ReadArgs@l#2\relax#3#1\@nil#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstsetup}
% We load the most advanced \packagename{keyval} package available.
%    \begin{macrocode}
\IfFileExists{xkeyval.sty}{\RequirePackage{xkeyval}[2005/01/30]}
                          {\RequirePackage{keyval}[1997/11/10]}
%<*info>
\lst@GetAllocs
%</info>
%    \end{macrocode}
% The user interface macro changes catcodes for reading the argument.
%    \begin{macrocode}
\lst@UserCommand\lstsetup{\begingroup \lst@setcatcodes \lstset@}
%    \end{macrocode}
% The definition of the subcommand depends on the loaded package:
%    \begin{macrocode}
\@ifpackageloaded{xkeyval}
{\def\lstset@#1{\endgroup
   \ifx\@empty#1\@empty\else
%    \end{macrocode}
% For \packagename{xkeyval} we put the content of |\XKV@rm| on a stack.
% This is necessary for recursive calls of this definition.
%    \begin{macrocode}
     \let\lst@stackitem\XKV@rm \lst@Push\lst@XKVrmstack
     \setkeys*{lst}{#1}%
%    \end{macrocode}
% If some keys weren't present, we extract their names, \ldots
%    \begin{macrocode}
     \ifx\XKV@rm\@empty\else
       \def\lst@Do##1,{%
         \ifx\@nnil##1\@empty\else
           \lst@temp##1=\@nil
           \expandafter\lst@Do
         \fi}%
       \def\lst@temp##1=##2\@nil{##1,}%
       \edef\lst@arg{\expandafter\lst@Do\XKV@rm,\@nnil,}%
%    \end{macrocode}
% try to load them and (try to) set their values again.
%    \begin{macrocode}
       \lst@RequireAspects\lst@arg
       \setrmkeys{lst}\@empty
     \fi
     \lst@Pop\lst@XKVrmstack \let\XKV@rm\lst@stackitem
   \fi}%
   \global\let\lst@XKVrmstack\@empty}
%    \end{macrocode}
% If \packagename{xkeyval} is not present, we just set the keys.
%    \begin{macrocode}
{\def\lstset@#1{\endgroup
   \ifx\@empty#1\@empty\else \setkeys{lst}{#1}\fi}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@setcatcodes}
% contains all catcode changes for |\lstset|.
% For proper key=value items, catcodes of the equal-sign and the comma are set
%  to `other'.
%    \begin{macrocode}
\def\lst@setcatcodes{\makeatletter \catcode`==12\catcode`,=12\relax}
%    \end{macrocode}
% \end{macro}
%
%
% \section{Scanning input}
%
% This scanner engine is the most important part of the package.
% It not only converts the charaters of a listing into a token stream
%  \ldots\space well, in fact, it does exactly this.
% But in contrast to a compiler scanner, this scanner can't just remove
%  comments, linebreaks, and more general whitespaces.
% Here we have to keep them all, attach styles to portions of the source code,
%  deal with escaping to \LaTeX, omit delimiters on user request, etc.
% And possibly all this in combination with each other.
% So, this scanner is a little bit more complex.
% But only a tiny little bit.
%
%
% \subsection{Simple tokenizing}\label{iSimpleTokenizing}
%
%
% \subsubsection{Basic scanning classes}
%
% The idea is as follows:
% Each character belongs to a character class (letter, digit, delimiter,
%  operator, and so on) and whenever two consecutive characters differ in their
%  class, we've found the end of a token and start a new one.
% This, of course, is not sufficient to scan the hexadecimal number |0x1f|, the
%  identifier |x1|, and the floating point number |-12.5e6|.
% We need to refine `whenever two consecutive' and `differ in their class'.
%
% In the following we define a couple of scanning macros
%  |\lst@Scan@|\meta{class} such that, for example, |\lst@Scan@i x\lst@Scan@d 1|
%  will result in the token |x1|.
% The class |i| represents characters belonging to identifiers and |d| stands for
%  digit.
%
% \begin{macro}{\lst@Scan}
% |\lst@scan@|\meta{class} \meta{character}
%
% Almost all |\lst@Scan@|\meta{class} macros will be built on top of this
%  definition.
% It requires two arguments in all, the class and the character.
% Whenever the given class differs from the current class, the current token
%  ships to the token stream and the scan class is set for the next
%  token---the subclass is a refinement mentioned in the first paragraph above
%  and is explained later.
% In any case the character is saved in |\lst@recentchar| and added to the
%  (possibly empty) token.
%    \begin{macrocode}
\def\lst@Scan#1{%
  \lst@scanifx\lst@scanclass#1\else
    \lst@AddTokenToStream
    \let\lst@recentscanclass\lst@scanclass
    \let\lst@scanclass#1\let\lst@scansubclass\@empty
  \fi
  \futurelet\lst@recentchar\lst@ScanAddCharToToken}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@scanifx}
% \begin{macro}{\lst@scanlowtrue}
% \begin{macro}{\lst@scanlowfalse}
% You may have noticed the |\lst@scanifx| above.
% It is used to turn on and off the simple tokenizing.
% Note that |\lst@scanlowfalse| does not care about the scanning class or the
%  current token, but gathers all characters in the current token.
%    \begin{macrocode}
\def\lst@scanlowtrue{\let\lst@scanifx\ifx}
\def\lst@scanlowfalse{\def\lst@scanifx##1##2{\iftrue}}
\lst@scanlowtrue
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@ResetScanClass}
% At the beginning of each line and in some other circumstances the scanning
%  parameters are reset.
%    \begin{macrocode}
\def\lst@ResetScanClass{%
  \let\lst@scanclass\lst@scan@ws \let\lst@scansubclass\@empty
  \let\lst@recentscanclass\lst@scan@ws}
\lst@AddToHook{InitScanBOL}{\lst@ResetScanClass}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@scan@i}
% \begin{macro}{\lst@Scan@i}
% Scanning a character, which always belongs to an identifier, is defined in
%  terms of |\lst@Scan|.
%    \begin{macrocode}
\def\lst@scan@i{i}
\@namedef{\@lst Scan@\lst@scan@i}{\lst@Scan\lst@scan@i}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@scan@o}
% \begin{macro}{\lst@Scan@o}
% Characters of operators are treated in the same way.
%    \begin{macrocode}
\def\lst@scan@o{o}
\@namedef{\@lst Scan@\lst@scan@o}{\lst@Scan\lst@scan@o}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@scan@m}
% \begin{macro}{\lst@Scan@m}
% Ditto miscellaneous characters and \ldots
%    \begin{macrocode}
\def\lst@scan@m{m}
\@namedef{\@lst Scan@\lst@scan@m}{\lst@Scan\lst@scan@m}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@scan@delimopen}
% \begin{macro}{\lst@Scan@delimopen}
% \begin{macro}{\lst@scan@delimclose}
% \begin{macro}{\lst@Scan@delimclose}
% opening and closing delimiters
%    \begin{macrocode}
\def\lst@scan@delimopen{delimopen}
\@namedef{\@lst Scan@\lst@scan@delimopen}{\lst@Scan\lst@scan@delimopen}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@scan@delimclose{delimclose}
\@namedef{\@lst Scan@\lst@scan@delimclose}{\lst@Scan\lst@scan@delimclose}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@scan@delim}
% \begin{macro}{\lst@Scan@delim}
% An unspecified delimiter is treated different: it's always a token on its own.
% Note that we have to use |\lst@scanifx| or the construction would be worth
%  nothing.
% So, we make a |\lst@Scan|-like definition but use |\relax| for the test,
%  which will always fail if low scanning is turned on.
%    \begin{macrocode}
\def\lst@scan@delim{delim}
\@namedef{\@lst Scan@\lst@scan@delim}{%
  \lst@scanifx\lst@scanclass\relax\else
    \lst@AddTokenToStream
    \let\lst@recentscanclass\lst@scanclass
    \let\lst@scanclass\lst@scan@delim \let\lst@scansubclass\@empty
  \fi
  \futurelet\lst@recentchar\lst@ScanAddCharToToken}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@scan@n}
% \begin{macro}{\lst@Scan@n}
% \begin{macro}{\lst@Scan@d}
% For numbers we have two kinds of character classes, which both use the same
%  |\lst@scan@n|:
% (a) `Numbers' will never belong to an identifier name.
%    \begin{macrocode}
\def\lst@scan@n{n}
\@namedef{\@lst Scan@\lst@scan@n}{\lst@Scan\lst@scan@n}
%    \end{macrocode}
% (b) `Digits' may be part of an identifier name.
% We just call |\lst@Scan| with the appropriate scanning class.
%    \begin{macrocode}
\def\lst@Scan@d{%
  \ifx\lst@scanclass\lst@scan@i
    \expandafter\lst@Scan\expandafter\lst@scan@i
  \else
    \expandafter\lst@Scan\expandafter\lst@scan@n
  \fi}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \subsubsection{Advanced scanning classes}
%
% \begin{macro}{\lst@scan@fpe}
% \begin{macro}{\lst@Scan@fpdot}
% \begin{macro}{\lst@Scan@fpe}
% \begin{macro}{\lst@Scan@fppm}
% The scanning class for arbitrary (floating point) numbers is a subclass.
%    \begin{macrocode}
\def\lst@scan@fpe{fpe}
%    \end{macrocode}
% Thus the following macro differs from the ones above.
% The first argument tells us which scanning macro is to be used if there is a
%  dot outside a floating point number.
% If we already scan a number with no subclass, we set the subclass and continue
%  to scan the number.
%    \begin{macrocode}
\def\lst@Scan@fpdot#1#2{%
  \def\lst@next{#1#2}%
  \ifx\lst@scanclass\lst@scan@n
    \ifx\lst@scansubclass\@empty
      \let\lst@scansubclass\relax \def\lst@next{\lst@Scan@n #2}%
    \fi
  \else
%    \end{macrocode}
% Otherwise: If the next character uses |\lst@Scan@d|, we attach the dot to the
%  next token.
% Otherwise we use the basic scanning macro |#1|.
%    \begin{macrocode}
    \def\lst@next{\lst@IfNextScan\lst@Scan@d{\lst@Scan@n #2}%
                                            {#1#2}}%
  \fi
  \lst@next}
%    \end{macrocode}
% For the |e|-notation the subclass is set (if and) only if it is empty or
%  |\relax|.
%    \begin{macrocode}
\def\lst@Scan@fpe#1{%
  \def\lst@next{#1}%
  \ifx\lst@scanclass\lst@scan@n
    \ifx\lst@scansubclass\@empty
      \let\lst@scansubclass\lst@scan@fpe \let\lst@next\lst@Scan@n
    \else \ifx\lst@scansubclass\relax
      \let\lst@scansubclass\lst@scan@fpe \let\lst@next\lst@Scan@n
    \fi \fi
  \fi
  \lst@next}
%    \end{macrocode}
% Plus and minus belong to the floating point number only if we're scanning an
% |e|-notation.
%    \begin{macrocode}
\def\lst@Scan@fppm#1#2{%
  \ifx\lst@scanclass\lst@scan@n
    \ifx\lst@scansubclass\lst@scan@fpe \def\lst@next{\lst@Scan@n #2}%
                                 \else \def\lst@next{#1#2}\fi
  \else
%    \end{macrocode}
% If we don't scan a number yet, a plus or minus in front of a digit or dot will
%  start a number.
%    \begin{macrocode}
    \def\lst@next{\lst@IfNextScan\lst@Scan@d{\lst@Scan@n #2}%
                  {\lst@IfNextScan\lst@Scan@fpdot{\lst@Scan@n #2}%
                                                 {#1#2}}}%
  \fi
  \lst@next}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@scan@hex}
% \begin{macro}{\lst@Scan@hexx}
% \begin{macro}{\lst@Scan@hexaf}
% Now we go for hexadecimal numbers.
%    \begin{macrocode}
\def\lst@scan@hex{hex}
%    \end{macrocode}
% The macro checks the current token for being \(0\) and sets the subclass if
%  necessary.
%    \begin{macrocode}
\def\lst@Scan@hexx#1{%
  \def\lst@next{#1}%
  \ifx\lst@scanclass\lst@scan@n
    \lst@IfToken{0}%
    {\let\lst@scansubclass\lst@scan@hex
     \def\lst@next{\lst@Scan\lst@scan@n}}%
    {}%
  \fi
  \lst@next}
%    \end{macrocode}
% In hexadecimal mode the characters |a| to |f| and |A| to |F| will be added to
%  the number.
%    \begin{macrocode}
\def\lst@Scan@hexaf#1{%
  \def\lst@next{#1}%
  \ifx\lst@scanclass\lst@scan@n \ifx\lst@scansubclass\lst@scan@hex
    \def\lst@next{\lst@Scan\lst@scan@n}%
  \fi \fi
  \lst@next}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@scan@ws}
% The class id for whitespaces.
%    \begin{macrocode}
\def\lst@scan@ws{ws}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@Scan@space}
% Scanning a space is similar to |\lst@Scan| except that the class is known
%  implicitly and that we don't save the space in |\lst@recentchar|.
%    \begin{macrocode}
\def\lst@Scan@space{%
  \lst@scanifx\lst@scanclass\lst@scan@ws\else
    \lst@AddTokenToStream
    \let\lst@recentscanclass\lst@scanclass
    \let\lst@scanclass\lst@scan@ws \let\lst@scansubclass\@empty
  \fi
  \lst@ScanAddCharToToken}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{tabsize}
% checks the argument and/or saves it.
%    \begin{macrocode}
\lst@Key{tabsize}{8}
  {\ifnum#1>\z@ \def\lst@tabsize{#1}\else
     \lst@Error{Strict positive integer expected}%
               {You can't use `#1' as tabsize. \@ehc}%
   \fi}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@Scan@tab}
% A tabulator is like a space, \ldots
%    \begin{macrocode}
\def\lst@Scan@tab#1{%
  \lst@scanifx\lst@scanclass\lst@scan@ws\else
    \lst@AddTokenToStream
    \let\lst@recentscanclass\lst@scanclass
    \let\lst@scanclass\lst@scan@ws \let\lst@scansubclass\@empty
  \fi
%    \end{macrocode}
% but we also have to determine its actual length.
%    \begin{macrocode}
  \@tempcnta\numexpr \lst@streamlength+\lst@length\relax
  \divide \@tempcnta\lst@tabsize
  \advance\@tempcnta\@ne
  \@tempcnta\numexpr \lst@tabsize*\@tempcnta-\lst@streamlength-\lst@length\relax
%    \end{macrocode}
% We adjust the token length in advance to \ldots
%    \begin{macrocode}
  \advance\lst@length\@tempcnta
  \advance\lst@length\m@ne
%    \end{macrocode}
% adding |#1\@gobble|\marg{length} to the token.
% Processing the token stream, the tabulator can just grab its length and the
%  length information does no harm in the sense of property (2) in section
%  \ref{iStandardCharacters}.
%    \begin{macrocode}
  \expandafter\lst@ScanAddCharToToken\expandafter{\expandafter
      #1\expandafter\@gobble\expandafter{\the\@tempcnta}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ScanUTFviii@ii}
% \begin{macro}{\lst@ScanUTFviii@iii}
% \begin{macro}{\lst@ScanUTFviii@iv}
% Let's finally look at scanning an UTF8 multibyte character.
% These macros read one, two, or three additional bytes/characters ahead and
%  let another macro do the main work.
%    \begin{macrocode}
\def\lst@ScanUTFviii@ii#1#2{\lst@ScanUTFviii\lst@scan@i#1#2}
\def\lst@ScanUTFviii@iii#1#2#3{\lst@ScanUTFviii\lst@scan@i#1{#2#3}}
\def\lst@ScanUTFviii@iv#1#2#3#4{\lst@ScanUTFviii\lst@scan@i#1{#2#3#4}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@ScanUTFviii}
% |\lst@scan@|\meta{class}\meta{UTF macro}\marg{characters}
% inserts a multibyte character to the token.
% \meta{UTF macro} is not a definition from the utf8 \packagename{inputenc}
%  file.
% It's a |\lst@um|\meta{char}, which eventually calls the correct macro, see
%  section \ref{iStandardCharacters}.
%
% It starts as usual:
% Whenever the given class differs from the current class, the current token
%  ships to the token stream and the scan class is set for the next
%  token.
%    \begin{macrocode}
\def\lst@ScanUTFviii#1#2#3{%
  \lst@scanifx\lst@scanclass#1\else
    \lst@AddTokenToStream
    \let\lst@recentscanclass\lst@scanclass
    \let\lst@scanclass#1\let\lst@scansubclass\@empty
  \fi
%    \end{macrocode}
% To add the multibyte character, we first scan the character sequence with
%  low-level and high-level tokenizing turned off.
% The two |\xdef|s expand the characters within to character tokens.
%    \begin{macrocode}
  \begingroup
    \lst@ResetToken \lst@scanlowfalse \lst@scanhighfalse
    \lst@ScanNextChar#3^^00%
    \xdef\@gtempa{\the\lst@token}\xdef\@gtempa{\@gtempa}%
  \endgroup
  \let\lst@recentchar\@empty
%    \end{macrocode}
% Now we add |\lst@UTFviii{|\meta{UTF macro}\meta{character tokens}|}| to the
%  token.
%    \begin{macrocode}
  \expandafter\lst@ScanAddCharToToken\expandafter
      {\expandafter\lst@UTFviii\expandafter{\expandafter#2\@gtempa}}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{The current token and stream}
%
% Before getting too deeply lost in the scanning process, we define some macros
%  used just above and allocate some necessary registers.
% We keep various data about the current token: the character string, its
%  length, and the most recently added character.
%
% \begin{macro}{\lst@token}
% \begin{macro}{\lst@length}
% \begin{macro}{\lst@extra}
% The token register keeps the character string and the counter its length.
% The macro may keep extra information about the token---it is used for keyword
%  detection.
%    \begin{macrocode}
\newtoks\lst@token
\newcount\lst@length
\let\lst@extra\@empty
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@ResetToken}
% \begin{macro}{\lst@recentchar}
% This is how and where the current token data and |\lst@recentchar| get empty.
%    \begin{macrocode}
\def\lst@ResetToken{%
  \lst@token{}\lst@length\z@ \let\lst@extra\@empty
  \let\lst@recentchar\@empty}
\lst@AddToHook{InitVarsBOL}{\lst@ResetToken}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@AddCharToToken}
% adds the argument to the token, but does not modify |\lst@recentchar|.
%    \begin{macrocode}
\def\lst@AddCharToToken#1{%
  \advance\lst@length\@ne \lst@token=\expandafter{\the\lst@token#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ScanAddCharToToken}
% continues the scanning at the end.
%    \begin{macrocode}
\def\lst@ScanAddCharToToken#1{%
  \advance\lst@length\@ne \lst@token=\expandafter{\the\lst@token#1}%
  \lst@ScanNextChar}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@IfToken}
% If we need to test against the token, we'll use this macro:
%    \begin{macrocode}
\def\lst@IfToken#1{%
  \def\reserved@a{#1}\edef\reserved@b{\the\lst@token}%
  \ifx\reserved@a\reserved@b \expandafter\@firstoftwo
                       \else \expandafter\@secondoftwo \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ScanToken}
% This is a small application of |\lst@scanlowfalse| and
%  |\lst@scanhighfalse|---the latter is defined later.
% To scan |#2| as one single token, we turn off the low and high level scanning.
% The character |^^00|\(=\)|^^@| interrupts the scanning.
%    \begin{macrocode}
\def\lst@ScanToken#1#2{%
  \let\lst@scanclass#1%
  \begingroup
    \lst@scanlowfalse \lst@scanhighfalse
    #2^^@%
    \xdef\@gtempa{\lst@token{\the\lst@token}%
                  \lst@length\the\lst@length\relax}%
  \endgroup
  \@gtempa}
%    \end{macrocode}
% \end{macro}
%
% Now, let's turn to the token stream.
%
% \begin{macro}{\lst@ResetTokenStream}
% The current token stream is kept in a macro definition.
%    \begin{macrocode}
\def\lst@ResetTokenStream{%
  \let\lst@tokenstream\@empty \lst@streamlength\z@}
\lst@AddToHook{InitScanBOL}{\lst@ResetTokenStream}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@streamlength}
% \begin{macro}{\lst@CalcColumn}
% |\lst@streamlength| holds the number of characters in the current stream.
% Thus together with |\lst@length| one can determine the current column.
%    \begin{macrocode}
\newcount\lst@streamlength
\lst@ResetTokenStream
%\def\lst@CalcColumn{%
%  \@tempcnta\lst@streamlength \advance\@tempcnta\lst@length}
\def\lst@currcolumn{\numexpr\lst@streamlength+\lst@length}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@AddTokenToStream}
% Add nonempty tokens in the form
%  |\lst@Process@|\meta{class}\marg{token}\marg{length} \marg{extra}.
% Note that the hook can modify the data.
%    \begin{macrocode}
\def\lst@AddTokenToStream{%
  \ifnum\lst@length>\z@
    \lsthk@AddTokenToStream
%    \end{macrocode}
%    \begin{macrocode}
    \advance\lst@streamlength\lst@length
    \edef\lst@temp{\expandafter\noexpand\csname\@lst Process@\lst@scanclass
                   \endcsname{\the\lst@token}{\the\lst@length}}%
    \lst@elAddTo\lst@temp{\expandafter{\lst@extra}}%
    \expandafter\lst@AddToTokenStream\expandafter{\lst@temp}%
%    \end{macrocode}
%    \begin{macrocode}
    \lsthk@PostAddTokenToStream
    \global\let\lsthk@PostAddTokenToStream\@empty
    \lst@ResetToken
    \lst@ResetScanClass
  \fi}
\lst@AddToHook{AddTokenToStream}{}% init
\lst@AddToHook{PostAddTokenToStream}{}% init
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@AddToTokenStream}
% The following definition might gobble the `add to' command.
%    \begin{macrocode}
\def\lst@AddToTokenStream{%
  \lst@ifaddtostream\else \expandafter\@gobblethree \fi
  \lst@lAddTo\lst@tokenstream}
%    \end{macrocode}
%    \begin{macrocode}
\let\lst@ifaddtostream\iftrue % init
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{The character table}
%
%
% \subsubsection{Standard characters}\label{iStandardCharacters}
%
% Currently we ensured that |\lst@Scan@i x\lst@Scan@d 1| leads to the token
%  |x1|.
% Now, if the two input characters |x1| (i.e.~read from the the source code)
%  expand to |\lst@Scan@i x\lst@Scan@d 1|, we're done.
% Kind of.
%
% The standard character table defines the default behaviour of each input
%  character.
% It says (character table entry 120) |\def\lst@CT120{\lst@Scan@i x}|.
% So, if we turn the input character |x| into |\lst@CT120|, this expands to
%  |\lst@Scan@i x|, which in turn takes all necessary actions to complete the
%  scanning of that character.
%
% \begin{macro}{\lst@ScanNextChar}
% \begin{macro}{\lst@ScanNextCharScan}
% Here we call the character table entries.
% Since the definition changes sometimes, e.g.~to drop the input, we keep the
%  original meaning in another macro.
%    \begin{macrocode}
\def\lst@ScanNextChar#1{\csname\@lst CT\number`#1\endcsname}
\let\lst@ScanNextCharScan\lst@ScanNextChar
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@GetScanChar}
% Here we extract the `character' from |\lst@CT|\meta{number} and assign it to
%  |#2|.
%    \begin{macrocode}
\def\lst@GetScanChar#1#2{%
  \ifcsname\@lst CT\number`#1\endcsname
    \expandafter\expandafter\expandafter\lst@GetScanChar@
      \csname\@lst CT\number`#1\endcsname\@nil #2%
  \else
    \let#2\relax
  \fi}
%    \end{macrocode}
% The scanning part might be one or two tokens.
% This is easily distinguished and we assign the following token to |#4|.
%    \begin{macrocode}
\def\lst@GetScanChar@#1#2#3\@nil#4{%
  \ifx\@empty#3\@empty \let#4#2\else \let#4#3\fi}
%    \end{macrocode}
% \end{macro}
%
% But it is not all that easy.
% To simplify the later process of typesetting and keyword detection, the token
%  must meet two properties:
% (1) It is printable as is, i.e.~the token put into a box typesets the token.
% (2) Each character is or expands to a \emph{character token} in the sense of
%  \TeX.
%
% Some characters like |_| and |$| are not directly printable or are not printed
%  well like |*| and |-| as * and - show.
% For each such \meta{char} we define a container macro with the name
%  |\lst@um|\meta{char} and the replacement text |\lst@UM |\meta{char} (|UM| for
%  `use macro' in opposition to simple characters like a, b, and so on).
% Note that the former \meta{char} belongs to the control sequence and the
%  latter is a character token (possibly) read by |\lst@UM| to ensure (1) and
%  (2).
%
% \begin{macro}{\lst@UM}
% With the default definition we have (2).
% |\lst@UMprint| is used for (1).
%    \begin{macrocode}
\let\lst@UM\@empty
\def\lst@UMprint#1{\csname\@lst um#1@\endcsname}
%    \end{macrocode}
% The following is just a temporary helper macro to define |\lst@um|\meta{char}.
% It reads a list of character codes and makes the appropriate definitions.
%    \begin{macrocode}
\def\lst@Do#1#2{%
  \ifnum#1>\z@
    \begingroup\lccode`\/=#1\lowercase{\endgroup
    \expandafter\def\csname\@lst um/\endcsname{\lst@UM /}%
    \expandafter\def\csname\@lst um/@\endcsname{#2}}%
    \expandafter\lst@Do
  \fi}
%    \end{macrocode}
% Now we actually define the containers.
%    \begin{macrocode}
\lst@Do
  {"09}\lst@umtabulator
  {"20}\lst@umspace
  {"23}\#%
  {"24}\textdollar
  {"25}\%%
  {"26}\&%
  {"27}{\lst@nolig\lst@ifupquote \textquotesingle \else \char39\relax \fi}%
  {"2A}{\lst@ttfamily*\textasteriskcentered}%
  {"2C}{\lst@nolig\char`,}%
  {"2D}{\lst@nolig\lst@ttfamily-{$-$}}%
  {"3C}{\lst@nolig\lst@ttfamily<\textless}%
  {"3E}{\lst@nolig\lst@ttfamily>\textgreater}%
  {"5C}{\lst@ttfamily{\char92}\textbackslash}%
  {"5E}\textasciicircum
  {"5F}{\lst@ttfamily{\char95}\textunderscore}%
  {"60}{\lst@nolig\lst@ifupquote \textasciigrave \else \char96\relax \fi}%
  {"7B}{\lst@ttfamily{\char123}\textbraceleft}%
  {"7C}{\lst@ttfamily|\textbar}%
  {"7D}{\lst@ttfamily{\char125}\textbraceright}%
  {"7E}\textasciitilde
  {"7F}-%
  \z@\@empty
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@nolig}
% The way we're preventing ligatures is the same as \LaTeX\ does.
%    \begin{macrocode}
\def\lst@nolig{\leavevmode\kern\z@}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ttfamily}
% The macro prints the first argument with active |\ttfamily| font or the second.
% This ensures proper printing of some characters, see the usage above.
%    \begin{macrocode}
\def\lst@ttfamily#1#2{\ifx\f@family\ttdefault #1\relax\else #2\fi}
%    \end{macrocode}
% |\ttdefault| is defined |\long|, so the |\ifx| doesn't work since |\f@family|
%  isn't |\long|.
% We go around this problem by redefining |\ttdefault| locally.
%    \begin{macrocode}
\lst@AddToHook{Init}{\edef\ttdefault{\ttdefault}}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{upquote}
% has also been used above to decide which quote should be printed.
% We print an error message if the necessary \packagename{textcomp} commands are
%  not available.
%    \begin{macrocode}
\lst@Key{upquote}{false}[t]{\lstKV@SetIf{#1}\lst@ifupquote
  \lst@ifupquote
    \@ifundefined{textasciigrave}%
    {\let\KV@lst@upquote\@gobble
     \lstKV@SetIf f\lst@ifupquote \@gobble\fi
     \lst@Error{Option `upquote' requires package `textcomp'}\@eha}%
    {}%
  \fi}
%    \end{macrocode}
% If an \packagename{upquote} package is loaded, the \keyname{upquote} option
% is enabled by default.
%    \begin{macrocode}
\AtBeginDocument{%
  \@ifpackageloaded{upquote}{\RequirePackage{textcomp}%
                             \lstsetup{upquote}}{}%
  \@ifpackageloaded{upquote2}{\lstsetup{upquote}}{}}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@Def}
% \begin{macro}{\lst@Let}
% \marg{char number}
% define respectively assign a new value to a character table entry.
%    \begin{macrocode}
\def\lst@Def#1{\expandafter\def\csname\@lst CT\number#1\endcsname}
\def\lst@Let#1{\expandafter\let\csname\@lst CT\number#1\endcsname}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@DefStdChar}
% |\lst@Scan@|\meta{class}\marg{char number}
% Globally defines the character to use the given class.
% We use |\lst@um|\meta{char} instead of \meta{char} if necessary.
%    \begin{macrocode}
\def\lst@DefStdChar#1#2{%
  \lst@token{#1}%
  \begingroup\lccode`\/=#2\lowercase{\endgroup
  \edef\lst@arg{{\the\lst@token
                 \ifcsname\@lst um/\endcsname
                   \expandafter\noexpand\csname\@lst um/\endcsname
                 \else
                   /%
                 \fi}}}%
%    \end{macrocode}
% Now |\lst@arg| contains either |{\lst@Scan@|\meta{class} \meta{char}|}| or
%  |{\lst@Scan@|\meta{class} |\lst@um|\meta{char}|}|, where the latter
%  \meta{char} belongs to the control sequence.
%    \begin{macrocode}
  \global\@namedef{\@lst CT\number#2\expandafter}\lst@arg}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@Do}
% We use |\lst@DefStdChar| on each item to \ldots
%    \begin{macrocode}
\def\lst@Do#1#2{%
  \ifnum#2=\z@ \expandafter\@gobbletwo \else
    \lst@DefStdChar{#1}{#2}%
  \fi
  \lst@Do{#1}}
%    \end{macrocode}
% define standard characters.
% The character |^^@|\(=\)|^^00| is used to interrupt or end scanning by doing
%  nothing (but not being empty!).
%    \begin{macrocode}
\lst@Def{"00}{\@empty}
\lst@Do\lst@Scan@tab{"09}\z@
\lst@Def{"0A}{\lst@MProcessListing}
\lst@Def{"0C}{\lst@ProcessFormFeed}
\lst@Def{"0D}{\lst@MProcessListing}
\lst@Do\lst@Scan@space{"20}\z@
\lst@Do\lst@Scan@o
  {"21}{"2A}{"2B}{"2D}{"2F}{"3C}{"3D}{"3E}\z@ % !*+-/<=>
\lst@Do\lst@Scan@delimopen {"28}{"5B}{"7B}\z@ % ([{
\lst@Do\lst@Scan@delimclose{"29}{"5D}{"7D}\z@ % )]}
\lst@Do\lst@Scan@d % 0123456789
  {"30}{"31}{"32}{"33}{"34}{"35}{"36}{"37}{"38}{"39}%
  \z@
\lst@Do\lst@Scan@m % "#%&',.:;?\^`|~DEL
  {"22}{"23}{"25}{"26}{"27}{"2C}{"2E}{"3A}{"3B}{"3F}%
  {"5C}{"5E}{"60}{"7C}{"7E}{"7F}%
  \z@
\lst@Do{\lst@Scan@fpdot\lst@Scan@m}{"2E}\z@ % .
\lst@Do\lst@Scan@i
  {"24}{"5F}%                               $
  {"40}{"41}{"42}{"43}{"44}{"45}{"46}{"47}% @ABCDEFG
  {"48}{"49}{"4A}{"4B}{"4C}{"4D}{"4E}{"4F}% HIJKLMNO
  {"50}{"51}{"52}{"53}{"54}{"55}{"56}{"57}% PQRSTUVW
  {"58}{"59}{"5A}{"5F}%                     XYZ_
       {"61}{"62}{"63}{"64}{"65}{"66}{"67}%  abcdefg
  {"68}{"69}{"6A}{"6B}{"6C}{"6D}{"6E}{"6F}% hijklmno
  {"70}{"71}{"72}{"73}{"74}{"75}{"76}{"77}% pqrstuvw
  {"78}{"79}{"7A}%                          xyz
  \z@
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DefStdCharActive}
% |\lst@Scan@|\meta{class}\marg{char code}
%
% The case of an active character is discussed below.
%    \begin{macrocode}
\def\lst@DefStdCharActive#1#2{%
  \ifnum\catcode#2=\active
    \begingroup\lccode`\~=#2\lccode`\/=#2\lowercase{\endgroup
    \expandafter\lst@DefStdCharActive@~\@empty\@nil~/}{#1}%
  \else
%    \end{macrocode}
% If the character is not active, we might need to delete an old definition.
% Afterwards we can safely call the standard procedure.
%    \begin{macrocode}
    \begingroup\lccode`\~=#2\lccode`\/=#2\lowercase{\endgroup
    \ifcsname\@lst um/\endcsname
      \global\expandafter\let\csname\@lst um/\endcsname\lst@undefined
    \fi}%
    \lst@DefStdChar{#1}{#2}
  \fi}
%    \end{macrocode}
% If the character is active, we put it into |\lst@um|\meta{char}|@| and define
%  |\lst@um|\meta{char} to work like the `um'-macros above.
%    \begin{macrocode}
\def\lst@DefStdCharActive@#1#2\@nil#3#4#5{%
  \expandafter\gdef\csname\@lst um#4@\endcsname{#3}%
  \expandafter\gdef\csname\@lst um#4\endcsname{\lst@UM #4}%
%    \end{macrocode}
% |\lst@Scan@|\meta{class} is replaced by an UTF-scanning class if we detect
%  such a character.
%    \begin{macrocode}
       \ifx#1\UTFviii@two@octets \lst@DefStdChar\lst@ScanUTFviii@ii{`#4}%
  \else\ifx#1\UTFviii@three@octets \lst@DefStdChar\lst@ScanUTFviii@iii{`#4}%
  \else\ifx#1\UTFviii@four@octets \lst@DefStdChar\lst@ScanUTFviii@iv{`#4}%
  \else \lst@DefStdChar{#5}{`#4}%
  \fi \fi \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@UTFviii}
% This macro has been used in section \ref{iSimpleTokenizing} to indicate a
%  multibyte character in the token (stream).
% We must ensure properties (1) and (2).
% Moreover, if |\lst@FillFixed| reads the token character by character, it would
%  like to treat this macro as a printable character.
% The solution to all this is surprisingly short.
%
% If we don't typeset anything (e.g. when detecting keywords), |\lst@UM| is
%  empty and we just use |#1| (argument braces are discarded by reading the
%  argument).
% If we actually typeset the character, we check whether we're inside the
%  |\lst@FillFixed| loop by looking at |#1|.
% We just need to remove |\lst@hss| if necessary (i.e.~the first token of |#1|
%  equals |\expandafter|).
%    \begin{macrocode}
\def\lst@UTFviii#1{%
  \ifx\lst@UM\@empty\else \ifx \expandafter#1\unskip \fi \fi
  #1}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{rescanchars}
% \begin{macro}{\lst@RescanChars}
% makes a snapshot of the current meanings of the extended characters 128--256
%  and defines the extended standard characters.
%    \begin{macrocode}
\lst@Key{rescanchars}\relax[]{\lst@RescanChars}
\def\lst@RescanChars{%
  \@tempcnta128\relax \@tempcntb256\relax
  \loop \ifnum\@tempcnta<\@tempcntb
    \lst@DefStdCharActive\lst@Scan@i\@tempcnta
    \advance\@tempcnta\@ne
  \repeat
  \xdef\lst@scannedenc{\expandafter\@secondoftwo\@inpenc@undefined}}
%    \end{macrocode}
% In the case that no input encoding is specified (including
%  \packagename{inputenc} is not loaded):
%    \begin{macrocode}
\providecommand*\@inpenc@undefined{\@empty\@empty}%
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
%
% \begin{lstkey}{inputencoding}
% The key is simple.
%    \begin{macrocode}
\lst@Key{inputencoding}{}{\def\lst@inputenc{#1}}
\lst@AddToHook{EmptyStyle}{\let\lst@inputenc\@empty}
%    \end{macrocode}
% At the beginning of the document we update the input encoding without
%  (|\iffalse|) activating it.
%    \begin{macrocode}
\AtBeginDocument{%
  \lst@UpdateInputEncoding\iffalse
%    \end{macrocode}
% With loaded \packagename{inputenc} we update it every listing and also
%  activate the encoding.
% If the package is not present, the command is deactivated (to free memory).
%    \begin{macrocode}
  \@ifpackageloaded{inputenc}%
  {\lst@AddToHook{Init}{\lst@UpdateInputEncoding\iftrue}}%
  {\let\lst@UpdateInputEncoding\@gobble}%
}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@UpdateInputEncoding}
% \meta{activate encoding \alternative{\textbackslash iftrue,false}}
% An empty |\lst@inputenc| uses the currently selected encoding.
% Thus, we (re)scan the characters if it does not equal the scanned encoding.
%    \begin{macrocode}
\def\lst@UpdateInputEncoding#1{%
  \edef\lst@option{\expandafter\@secondoftwo\@inpenc@undefined}%
  \ifx\lst@inputenc\@empty
    \ifx\lst@scannedenc\lst@option\else \lst@RescanChars \fi
  \else
%    \end{macrocode}
% If the internal and the requested encodings are equal, we only need to
%  activate the encoding (if |#1| is true).
%    \begin{macrocode}
    \ifx\lst@inputenc\lst@scannedenc
      #1\inputencoding\lst@inputenc \fi
    \else
%    \end{macrocode}
% If the they differ, we need to (re)scan the characters.
% If the requested encoding is already selected, a simple |\lst@RescanChars| is
%  all we need.
% Otherwise we first need to select the correct encoding, make the scan, and
%  possibly switch back to the previous scheme.
%    \begin{macrocode}
      \ifx\lst@inputenc\lst@option
        \lst@RescanChars
      \else
        \inputencoding\lst@inputenc
        \lst@RescanChars
        #1\else\ifx\lst@option\@empty\else \inputencoding\lst@option \fi\fi
      \fi
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Changing standard characters}
%
% In this section we deal with two things:
% (1) Changing the basic |\lst@Scan@|\meta{class} a character belongs to and
% (2) selecting the character table with all modifications inserted later by
%     other features.
%
% \begin{macro}{\lst@IfNextScan}
% |\lst@Scan@|\meta{class}\marg{then}\marg{else}
% executes the appropriate part.
% If EOL is the next character, \meta{else} is used.
%
% This is a warm up.
% If not EOL, we expand the character's meaning to something like
%  |\lst@Scan@|\meta{class} \meta{char}, and \ldots
%    \begin{macrocode}
\def\lst@IfNextScan#1#2#3#4{%
  \lst@IfNextCharEOL{#3}%
  {\let\lst@arg#1\def\reserved@a{#2}\def\reserved@b{#3}%
   \expandafter\expandafter\expandafter\lst@IfNextScan@
      \csname\@lst CT\number`#4\endcsname\@empty\@nil}
  #4}
%    \end{macrocode}
% execute either \meta{then} or \meta{else}.
%    \begin{macrocode}
\def\lst@IfNextScan@#1#2\@nil{%
  \ifx\lst@arg#1\@empty \expandafter\reserved@a
                  \else \expandafter\reserved@b \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@AddCharClass}
% |\lst@Scan@|\meta{class}\meta{char}\ldots\meta{char}|^^00|
% adds code to |\lst@adjustcharclass| to make the listed characters belong to
%  the given class.
%
% Again, we expand the character table meaning of \meta{char} to do what we
%  need to do.
% For each item.
%    \begin{macrocode}
\def\lst@AddCharClass#1#2{%
  \ifnum`#2>\z@
    \expandafter\expandafter\expandafter\lst@AddCharClass@
        \csname\@lst CT\number`#2\endcsname\@nil{#1}{#2}%
  \else
    \expandafter\@gobbletwo
  \fi
  \lst@AddCharClass{#1}}
%    \end{macrocode}
% The submacro replaces the standard class |#1| by |#4|. Roughly speaking.
% Do you remember |\lst@Class@fpdot| (or any other advanced simple tokenizing
%  class)?
% In contrast to the basic classes, which read no argument (in the first stage),
%  it does read a \meta{basic class}.
% (Later on both types read another \meta{char}-argument).
% We have to take this into account.
% A basic standard class |#1| is easily detected by an empty |#3|.
% So we are able to choose |#2| or |#3| as \meta{char}.
%    \begin{macrocode}
\def\lst@AddCharClass@#1#2#3\@nil#4#5{%
  \ifx\@empty#3\@empty
    \lst@lAddTo\lst@adjustcharclass{\lst@Def{`#5}{#4#2}}%
  \else
    \lst@lAddTo\lst@adjustcharclass{\lst@Def{`#5}{#4#3}}%
  \fi}
%    \end{macrocode}
%    \begin{macrocode}
\let\lst@adjustcharclass\@empty % init
\lst@AddToHook{SetLanguage}{\let\lst@adjustcharclass\@empty}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{charclass}
% \begin{lstkey}{morecharclass}
% The keys are applications of the just defined macros.
%    \begin{macrocode}
\lst@Key{charclass}\relax{%
  \let\lst@adjustcharclass\@empty
  \KV@lst@morecharclass{#1}}
%    \end{macrocode}
% First we set some data macros.
%    \begin{macrocode}
\lst@Key{morecharclass}\relax{\lstKV@OArg[m]{#1}{%
  \lstKV@ReadArgs:{\lst@type\lst@arg}{##1}%
  \let\lst@temp\@empty
%    \end{macrocode}
% We build maximal two |\lst@Scan@|\meta{class}es and put them into |\lst@temp|.
% If a class is undefined, |\lst@temp| gets empty.
%    \begin{macrocode}
  \@ifundefined{\@lst Scan@\lst@type}{}%
  {\lst@elAddTo\lst@temp{\csname\@lst Scan@\lst@type\endcsname}%
   \ifx\lst@arg\@empty\else
     \@ifundefined{\@lst Scan@\lst@arg}%
     {\let\lst@temp\@empty}%
     {\lst@elAddTo\lst@temp{\csname\@lst Scan@\lst@arg\endcsname}}%
   \fi}%
%    \end{macrocode}
% We utilize |\lst@AddCharClass| to extend |\lst@adjustcharclass| if possible.
%    \begin{macrocode}
  \ifx\lst@temp\@empty
    \lst@Error{Unknown character class `##1'}\@ehc
  \else
    \expandafter\lst@AddCharClass\expandafter{\lst@temp}##2^^00%
  \fi}}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
%
% \begin{macro}{\lst@SelectCharTable}
% Here we put the things together.
% Save and change some catcodes and adjust the basic character classes.
%    \begin{macrocode}
\def\lst@SelectCharTable{%
  \edef\lst@RestoreCatcodes{%
    \catcode`\noexpand\ \the\catcode`\ \catcode`\noexpand\^^M\the\catcode`\^^M%
    \catcode`\noexpand\^^I\the\catcode`\^^I\catcode`\noexpand\%\the\catcode`\%%
    \catcode`\noexpand\\\the\catcode`\\\catcode`\noexpand\{\the\catcode`\{%
    \catcode`\noexpand\}\the\catcode`\}\catcode`\noexpand\#\the\catcode`\#%
    \catcode`\noexpand\^\the\catcode`\^}%
  \obeyspaces\obeylines \catcode`\^^I=12\relax
  \catcode`\%=12\relax \catcode`\\=12\relax
  \catcode`\{=12\relax \catcode`\}=12\relax
  \catcode`\#=12\relax \catcode`\^=12\relax
  \lst@adjustcharclass
%    \end{macrocode}
% Then we're ready for the major definitions like comment, string or general
%  delimiters, other keywords, transcriptions, and (almost) whatever else.
% Since |\lst@CharTableRedef| contains a list of |\do|-item, we only need to
%  define an appropriate |\do|, see section right below.
%    \begin{macrocode}
  \def\do##1##2##3{##3}\lst@CharTableRedefs
%    \end{macrocode}
% Two more ways to adjust the character table.
% |\lst@DefRange| does not count.
%    \begin{macrocode}
  \lsthk@SelectCharTable
  \lst@DeveloperSCT
  \lst@DefRange}
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{SelectCharTable}{}% init
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{SelectCharTable}
% \begin{lstkey}{MoreSelectCharTable}
% The keys to adjust |\lst@DeveloperSCT|.
%    \begin{macrocode}
\lst@Key{SelectCharTable}{}{\def\lst@DeveloperSCT{#1}}
\lst@Key{MoreSelectCharTable}\relax{\lst@lAddTo\lst@DeveloperSCT{#1}}
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{SetLanguage}{\let\lst@DeveloperSCT\@empty}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
%
%
% \subsubsection{High-level redefinitions}
%
% \begin{macro}{\lst@CharTableRedefs}
% This macro will hold most high-level (i.e.~not basic character class) changes
%  to the character table.
% Each list item is of the form
%  |\do|\meta{redef type (cs)}\marg{character sequence}\marg{defining commands}.
% The last argument contains both the type and character sequence to actually
%  perform the redefinition(s).
% The two arguments in front make adding and deleting the items much easier.
%    \begin{macrocode}
\let\lst@CharTableRedefs\@empty
\lst@AddToHook{SetLanguage}{\let\lst@CharTableRedefs\@empty}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@RedefDelete}
% \meta{redef type (cs)}\marg{character sequence}
%
% To delete a particular item, we define |\do| to compare the given type and
%  character sequence with each item in the list.
% If we've found a matching pair, we omit the item.
% Otherwise |\do| and the triple gets added to |\@gtempa|.
%    \begin{macrocode}
\def\lst@RedefDelete#1#2{%
  \begingroup
    \def\reserved@a{#1#2}
    \def\do##1##2##3{\def\reserved@b{##1##2}%
      \ifx\reserved@a\reserved@b\else
        \lst@AddTo\@gtempa{\do##1{##2}{##3}}%
      \fi}%
%    \end{macrocode}
% Now we only need to initialize |\@gtempa|, call |\lst@CharTableRedefs|, and
%  assign the new list.
%    \begin{macrocode}
    \global\let\@gtempa\@empty
    \lst@CharTableRedefs
  \endgroup
  \let\lst@CharTableRedefs\@gtempa}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@RedefDeleteClass}
% \marg{redef type (no cs, no preceding \texttt{lst@})}
%
% To delete a whole class, we will compare |\string| versions of the types.
% An item is omitted if the type in the list begins with the characters given by
%  the first argument.
% The submacro (with the string version of the type as argument) will define an
%  appropriate |\do|.
% So we only need to initialize |\@gtempa|, call |\lst@CharTableRedefs|, and
%  assign the new list.
%    \begin{macrocode}
\def\lst@RedefDeleteClass#1{%
  \begingroup
    \edef\lst@Test{\expandafter\string\csname\@lst #1\endcsname}%
    \expandafter\lst@RedefDeleteClass@\expandafter{\lst@Test}%
    \global\let\@gtempa\@empty
    \lst@CharTableRedefs
  \endgroup
  \let\lst@CharTableRedefs\@gtempa}
%    \end{macrocode}
% We define |\lst@Test| to have the argument text
%  |##1||\lst@|\meta{redef type}|##2|, where the characters between the
%  arguments have catcode 12.
% If and only if |##1| is empty on executing, we've found the (sub)type.
%    \begin{macrocode}
\def\lst@RedefDeleteClass@#1{%
  \def\lst@Test##1#1##2\relax{
    \ifx \@empty##1\@empty \expandafter\@firstoftwo
                     \else \expandafter\@secondoftwo \fi}%
%    \end{macrocode}
% Thus we define |\do| to drop the item in that case.
%    \begin{macrocode}
  \def\do##1##2##3{%
    \expandafter\lst@Test\string##1#1\relax
    {}%
    {\lst@AddTo\@gtempa{\do##1{##2}{##3}}}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@RedefInsert}
% \meta{redef type (cs)}\marg{character sequence}\marg{defining commands}
%
% Here we inserted the item at the correct position, i.e.~in front of all
%  items, which begin with \meta{character sequence}.
% |\lst@Test| is like above.
%    \begin{macrocode}
\def\lst@RedefInsert#1#2#3{%
  \begingroup
    \def\lst@Test##1#2##2\relax{
      \ifx \@empty##1\@empty \expandafter\@firstoftwo
                       \else \expandafter\@secondoftwo \fi}%
%    \end{macrocode}
% If the new item's character sequence is a subsequence of the current item,
%  the new item gets inserted in front of the current one (and we end the loop).
% Otherwise we add the current item and continue to the next one.
%    \begin{macrocode}
    \def\do##1##2##3{%
      \lst@Test##2#2\relax
      {\lst@AddTo\@gtempa{\do#1{#2}{#3}\do##1{##2}{##3}}%
       \lst@RedefInsert@end}%
      {\lst@AddTo\@gtempa{\do##1{##2}{##3}}}}%
%    \end{macrocode}
% Here we terminate the content of |\lst@CharTableRedefs| by |\relax| and add
%  the new item if we've reached the end of the list.
%    \begin{macrocode}
    \global\let\@gtempa\@empty
    \lst@CharTableRedefs\relax
    \lst@AddTo\@gtempa{\do#1{#2}{#3}}%
  \endgroup
  \let\lst@CharTableRedefs\@gtempa}
%    \end{macrocode}
% To make this an if-and-only-if, we add the rest to the list and gobble the bad
%  command.
%    \begin{macrocode}
\def\lst@RedefInsert@end#1\relax{\lst@AddTo\@gtempa{#1}\@gobblethree}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@RedefConvert}
% \meta{(sequence of braced) character(s) (arguments)}|\@nnil|
%
% The character sequences used (including the ones inside
%  \meta{defining commands}) are converted.
% All characters except the comma get catcode 12.
% A comma gets catcode 11 to distinguish it from the comma in comma separated
%  lists.
%
% A braced argument is read and converted.
% Then we add the result together with group delimiters to |\lst@arg|
%  and continue the conversion.
%    \begin{macrocode}
\def\lst@RedefConvert{\@ifnextchar\bgroup\lst@RedefConvertArg\lst@RedefConvert@}
\def\lst@RedefConvertArg#1{%
  {\let\lst@arg\@empty
   \lst@RedefConvert#1\@nnil
   \global\let\@gtempa\lst@arg}%
  \lst@elAddTo\lst@arg{\expandafter{\@gtempa}}%
  \lst@RedefConvert}
%    \end{macrocode}
% Having no |\bgroup| or equivalent next character, we check whether we've found
%  the end of the input, and otherwise convert the character and continue.
%    \begin{macrocode}
\begingroup\lccode`\c=`\,\lowercase{\endgroup
\def\lst@RedefConvert@#1{%
  \ifx\@nnil#1\else
    \ifnum`#1=`\,%
      \lst@lAddTo\lst@arg c%
    \else
      \begingroup\lccode`\/=`#1\lowercase{\endgroup
      \lst@lAddTo\lst@arg/}%
    \fi
    \expandafter\lst@RedefConvert
  \fi}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DefSaveDef}
% \begin{macro}{\lst@LetSaveDef}
% \marg{char code}\meta{save cs}\meta{parameter text}\marg{replacement text}\endgraf\noindent
% \marg{char code}\meta{save cs}\meta{replacement cs}
%
% These macros save the previous definition and define or assign a new one.
%    \begin{macrocode}
\def\lst@DefSaveDef#1#2{%
  \expandafter\let\expandafter#2\csname\@lst CT\number#1\endcsname
  \expandafter\def\csname\@lst CT\number#1\endcsname}
\def\lst@LetSaveDef#1#2{%
  \expandafter\let\expandafter#2\csname\@lst CT\number#1\endcsname
  \expandafter\let\csname\@lst CT\number#1\endcsname}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@ifscanhigh}
% \begin{macro}{\lst@ifamc}
% You should remember |\lst@scanlowtrue|\(\vert\)|false|, which control the
%  simple tokenizing.
% The switches |\lst@ifscanhigh| and |\lst@ifamc| now control the higher level
%  process.
%
% Redefinitions made by |\lst@CDef| and |\lst@CDefX| are active if and only if
%  |\lst@ifscanhigh| is true.
% Redefinitions by |\lst@CDefAMC| additionally take |\lst@ifamc| (allow mode
%  changes) into account: They are active if one of the switches signals true.
% Note that |\lst@scanhightrue| and |\lst@scanhighfalse| also set |\lst@ifamc|,
%  so the latter can be adjusted afterwards only.
%    \begin{macrocode}
\def\lst@scanhightrue{\lst@amctrue \let\lst@ifscanhigh\iftrue}
\def\lst@scanhighfalse{\lst@amcfalse \let\lst@ifscanhigh\iffalse}
\def\lst@amctrue{\let\lst@ifamc\iftrue}
\def\lst@amcfalse{\let\lst@ifamc\iffalse}
\lst@scanhightrue
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@CDef}
% \marg{\meta{1st}\marg{2nd}\marg{rest}}\meta{saved 1st}\marg{execute}\marg{pre}\marg{post}
%
% We unfold the first parameter and use \meta{save 1st}\meta{2nd}\meta{rest} as
%  replacement argument to |\lst@CDefIt|.
%    \begin{macrocode}
\def\lst@CDef#1{\lst@CDef@#1}
\def\lst@CDef@#1#2#3#4{\lst@CDefIt#1{#2}{#3}{#4#2#3}#4}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@CDefX}
% drops the characters by using an empty \meta{replace}-argument to |\lst@CDefIt|.
%    \begin{macrocode}
\def\lst@CDefX#1{\lst@CDefX@#1}
\def\lst@CDefX@#1#2#3{\lst@CDefIt#1{#2}{#3}{}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@CDefIt}
% \marg{1st}\marg{2nd}\marg{rest}\marg{replace}\meta{saved 1st}\marg{execute}\marg{pre}\marg{post}
%
% This is the main working procedure for the previous two macros.
% The 2nd and 3rd argument may be empty (not equivalent to empty!).
%    \begin{macrocode}
\def\lst@CDefIt#1#2#3#4#5#6#7#8{%
  \ifx\@empty#2\@empty
%    \end{macrocode}
% For a single character we just execute the arguments in the correct order, if
%  high level scanning is activated:
% \meta{execute} and \meta{pre}\meta{replace}\meta{post} via |\lst@next|.
% Since other cases require this |\lst@next|-construction, we also use it here.
%    \begin{macrocode}
    \lst@Def{`#1}{%
        \lst@ifscanhigh
          #6\def\lst@next{#7#4#8}%
        \else
          \let\lst@next#5%
        \fi
        \lst@next}%
  \else\ifx\@empty#3\@empty
%    \end{macrocode}
% For a two character sequence we need to check the character code of |##1| and
%  |#2|.
%    \begin{macrocode}
    \lst@Def{`#1}##1{%
        \lst@ifscanhigh
          #6%
          \ifnum`##1=`#2\def\lst@next{#7#4#8}\else
                        \def\lst@next{#5##1}\fi
        \else
          \def\lst@next{#5##1}%
        \fi
        \lst@next}%
  \else
%    \end{macrocode}
% We do the same for an arbitrary character sequence---except that we have to
%  use |\lst@IfNextChars| instead of |\ifnum|.
%    \begin{macrocode}
    \lst@Def{`#1}{%
        \lst@ifscanhigh
          #6%
          \def\lst@next{\lst@IfNextChars{#2#3}{#7#4#8}%
                            {\expandafter#5\lst@eaten}}%
        \else
          \let\lst@next#5%
        \fi
        \lst@next}%
  \fi \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@CDefAMC}
% \begin{macro}{\lst@CDefItAMC}
% \marg{\meta{1st}\marg{2nd}\marg{rest}}\meta{saved 1st}\marg{execute}\marg{pre}\marg{post}
%
% And now similar definitions, which also use |\lst@ifamc|.
%    \begin{macrocode}
\def\lst@CDefAMC#1{\lst@CDefAMC@#1}
\def\lst@CDefAMC@#1#2#3#4{\lst@CDefItAMC#1{#2}{#3}{#4#2#3}#4}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@CDefItAMC#1#2#3#4#5#6#7#8{%
  \ifx\@empty#2\@empty
    \lst@Def{`#1}{%
        \def\lst@next{#7#4#8}%
        \lst@ifscanhigh #6\else \lst@ifamc #6\else
          \let\lst@next#5%
        \fi \fi
        \lst@next}%
  \else\ifx\@empty#3\@empty
    \lst@Def{`#1}##1{%
        \ifnum`##1=`#2\def\lst@next{#7#4#8}\else
                      \def\lst@next{#5##1}\fi
        \lst@ifscanhigh #6\else \lst@ifamc #6\else
          \def\lst@next{#5##1}%
        \fi \fi
        \lst@next}%
  \else
    \lst@Def{`#1}{%
        \def\lst@next{\lst@IfNextChars{#2#3}{#7#4#8}%
                          {\expandafter#5\lst@eaten}}%
        \lst@ifscanhigh #6\else \lst@ifamc #6\else
          \let\lst@next#5%
        \fi \fi
        \lst@next}%
  \fi \fi}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% The recent commands actually modify the characters.
% Now we define a macro which helps us in providing the strange arguments
%  \meta{1st}\marg{2nd}\marg{rest}\meta{save 1st} to the above definitions.
%
% \begin{macro}{\lst@CArg}
% \meta{character sequence}|\relax|\marg{execute}
%
% executes the given commands with proper first two arguments for |\lst@CDef|.
% (So |\lst@CDef| should be the last token in \meta{execute}.)
% We get an undefined macro and use |\@empty\@empty\relax| as delimiter for
%  the submacro.
%    \begin{macrocode}
\def\lst@CArg#1#2\relax{%
  \lccode`\/=`#1\lowercase{\def\lst@temp{/}}%
  \lst@GetFreeMacro{lstc@\lst@temp}%
  \expandafter\lst@CArg@\lst@freemacro#1#2\@empty\@empty\relax}
%    \end{macrocode}
% Save meaning of \meta{1st}=|#2| in \meta{save 1st}=|#1| and call the macro
%  |#6| with correct arguments.
% From version 1.0 on, |#2|, |#3| and |#4| (respectively empty arguments) are
%  tied together with group braces.
% This allows us to save two arguments in other definitions, for example in
%  |\lst@DefDelimB|.
%    \begin{macrocode}
\def\lst@CArg@#1#2#3#4\@empty#5\relax#6{%
  \expandafter\let\expandafter#1\csname\@lst CT\number`#2\endcsname
  \ifx\@empty#3\@empty
    \def\lst@next{#6{#2{}{}}}%
  \else
    \def\lst@next{#6{#2#3{#4}}}%
  \fi
  \lst@next #1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@GetFreeMacro}
% Initialize |\@tempcnta| and advance the counter until reaching a `free'
% control sequence.
%    \begin{macrocode}
\def\lst@GetFreeMacro#1{%
  \@tempcnta\z@
  \loop \expandafter\unless\expandafter\ifx
          \csname#1\the\@tempcnta\endcsname\relax
    \advance\@tempcnta\@ne
  \repeat
  \edef\lst@freemacro{\csname#1\the\@tempcnta\endcsname}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Internal modes}
%
% \begin{macro}{\lst@modestack}
% We use a stack to manage mode changes.
%    \begin{macrocode}
\global\let\lst@modestack\@empty
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@EnterMode}
% Each mode change saves the current mode number in |\lst@stackitem|, executes
%  mode specific settings (third code line), and eventually puts the item on a
%  stack.
% If an escape (to \LaTeX) started, we have to do some additional things.
%    \begin{macrocode}
\def\lst@EnterMode#1#2{%
  \xdef\lst@stackitem{\noexpand\lst@mode\the\lst@mode\relax}%
  \lst@mode=#1\relax \csname\@lst modeset\the\lst@mode\endcsname
  #2%
  \lst@Push\lst@modestack
  \lst@ifescape \lst@BeginEscape \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@LeaveMode}
% If the current mode is not |\lst@nomode|, we first end an active escape here,
%  but this is not the usual place an escape should end, see |\lst@DelimClose|
%  in section \ref{iOpeningAndClosing}.
% If present, we use |\lst@modeset|\meta{mode}|end| and finally get the topmost
%  item from the stack to restore the mode number and other settings.
%    \begin{macrocode}
\def\lst@LeaveMode{%
  \ifnum\lst@mode=\lst@nomode\else
    \lst@ifescape \lst@EndEscape \fi
    \ifcsname\@lst modeset\the\lst@mode end\endcsname
      \csname\@lst modeset\the\lst@mode end\endcsname
    \fi
    \lst@Pop\lst@modestack \lst@stackitem
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@LeaveModeTo}
% \marg{mode number}
% brings the processing \emph{back} to the specified mode.
% If the mode is not in the current mode sequence, this macro will loop
%  forever---theoretically.
%    \begin{macrocode}
\def\lst@LeaveModeTo#1{%
  \ifnum#1=\lst@mode \expandafter\@gobble \else
    \lst@LeaveMode
    \expandafter\lst@LeaveModeTo
  \fi
  {#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Mode classes}
%
% \begin{macro}{\lst@NewModeClass}
% \marg{class name}\marg{\alternative{true,false}}\marg{\alternative{true,false}}
%
% If and only if the switch |\lst@if#1| is undefined yet, we define the new mode
%  class.
% We initialize the mode set(ting), \ldots
%    \begin{macrocode}
\def\lst@NewModeClass#1#2#3{%
  \ifcsname\@lst if#1\endcsname
    \lst@Error{Mode class `#1' already defined}\@ehd
  \else
    \global\@namedef{\@lst modeset@#1}{\lst@InitModesF}%
%    \end{macrocode}
% define the switch |\lst@if|\meta{name} in a very special manner, and \ldots
%    \begin{macrocode}
    \expandafter\lst@NewModeClass@truefalse
      \csname\@lst if#1\expandafter\endcsname
      \csname\@lst #1true\expandafter\endcsname
      \csname\@lst #1true@\expandafter\endcsname
      \csname\@lst #1false\expandafter\endcsname
      \csname\@lst #1false@\endcsname
%    \end{macrocode}
% add mode initialization.
% |#2| and |#3| are in \textbraceleft|true|,|false|\textbraceright.
% The actual arguments might be the same in the case that a mode is initially
%  always on or off (like the escape mode).
%    \begin{macrocode}
    \lst@eAddTo\lst@InitModesT{\csname\@lst #1#2\endcsname}%
    \lst@eAddTo\lst@InitModesF{\csname\@lst #1#3\endcsname}%
  \fi}
%    \end{macrocode}
%    \begin{macrocode}
\let\lst@InitModesT\@empty % init
\let\lst@InitModesF\@empty % init
%    \end{macrocode}
% Now let's take a look at |\lst@if|\meta{name}.
% We define |\lst@|\meta{name}|true| to call a submacro if and only if it's not
%  true already.
% The submacro |\let|s it true and adds code to the stack item to reverse this.
% |\lst@|\meta{name}|false| is defined similarly.
% This is the way we keep track of the data when entering and leaving modes.
%    \begin{macrocode}
\def\lst@NewModeClass@truefalse#1#2#3#4#5{%
  \global\let#1\iffalse
  \gdef#2{#1\else#3\fi}\gdef#4{#1#5\fi}%
  \gdef#3{\lst@AddToStackItem{\global\let#1\iffalse}%
          \global\let#1\iftrue}%
  \gdef#5{\lst@AddToStackItem{\global\let#1\iftrue}%
          \global\let#1\iffalse}}
%    \end{macrocode}
% The kernel mode set uses an adjustable default (and |\lst@if| has no relevance
%  to the kernel except that it is for temporary use).
%    \begin{macrocode}
\def\lst@modeset@{\lst@kernelmodeset}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{initmodes}
% That default can be set here.
%    \begin{macrocode}
\lst@Key{initmodes}{true}[t]{\lstKV@SetIf{#1}\lst@if
  \lst@if \def\lst@kernelmodeset{\lst@InitModesT}%
    \else \def\lst@kernelmodeset{\lst@InitModesF}\fi}
\lst@AddToHook{SetLanguage}{\def\lst@kernelmodeset{\lst@InitModesT}}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@AddToModeSet}
% \marg{the mode or \texttt{@}class}\marg{content}
% adds the content to the mode set.
%    \begin{macrocode}
\def\lst@AddToModeSet#1{%
  \expandafter\lst@AddTo\csname\@lst modeset#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ifLmode}
% This conditional is defined in the same way as the mode class ifs, but it is
%  not part of |\lst@InitModeT| or |\lst@InitModeF|.
% Thus it doesn't belong to any mode set by default.
% Special delimiters use this it to automatically let the mode end at EOL.
%    \begin{macrocode}
\lst@NewModeClass@truefalse
  \lst@ifLmode\lst@Lmodetrue\lst@Lmodetrue@
              \lst@Lmodefalse\lst@Lmodefalse@
\lst@AddToHook{InitVars}{\lst@Lmodefalse}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@NewMode}
% If the mode class |#1| exists, we advance the number in |\lst@newmode| and use
%  |\chardef| to define the mode number.
%    \begin{macrocode}
\def\lst@NewMode{\lstKV@CountStars\lst@NewMode@}
\def\lst@NewMode@[#1]#2{%
  \ifcsname\@lst if#1\endcsname
    \xdef\lst@newmode{\the\numexpr \lst@newmode+1}%
    \global\chardef#2\lst@newmode\relax
%    \end{macrocode}
% Depending on the number of stars, we use the settings from the mode class or
%  do not touched the settings when entering this mode.
%    \begin{macrocode}
    \expandafter\xdef\csname\@lst modeset\the#2\endcsname
      {\ifcase\@tempcntb \expandafter\noexpand\csname\@lst modeset@#1\endcsname
       \else
       \fi}%
  \else
    \lst@Error{Unknown mode class `#1'}\@ehd
  \fi}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@newmode{\m@ne}% init
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@mode}
% \begin{macro}{\lst@nomode}
% \begin{macro}{\lst@Pmode}
% The counter |\lst@mode| keeps the current mode number while processing a
%  listing.
% We define the first mode and init the counter.
%    \begin{macrocode}
\lst@NewMode*[]\lst@nomode
\newcount\lst@mode \lst@mode\lst@nomode
%    \end{macrocode}
% If someone accidentially enters |\lst@nomode|, we give an error message.
%    \begin{macrocode}
\lst@AddToModeSet{\the\lst@nomode}{%
  \lst@Error{The package entered \string\lst@nomode\space explicitly}\@ehd}
%    \end{macrocode}
% The processing mode uses the kernel defaults as mode set (no stars).
%    \begin{macrocode}
\lst@NewMode[]\lst@Pmode
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@UseDynamicMode}
% Here |\lst@dynamicmode| substitutes |\lst@newmode| and all definitions are
%  local.
%    \begin{macrocode}
\def\lst@UseDynamicMode#1[#2]{%
  \ifcsname\@lst if#2s\endcsname\else
    \lst@Error{Unknown mode class `#2'}\@ehc
  \fi
  \edef\lst@dynamicmode{\the\numexpr \lst@dynamicmode+\@ne}%
%    \end{macrocode}
% We define |\lst@modeset|\meta{number} as seen above.
%    \begin{macrocode}
  \expandafter\edef\csname\@lst modeset\lst@dynamicmode\endcsname
    {\ifcase #1\expandafter\noexpand\csname\@lst modeset@#2s\endcsname
     \else
     \fi}%
  \expandafter\lst@UseDynamicMode@\expandafter{\lst@dynamicmode}}
\def\lst@UseDynamicMode@#1#2{#2{#1}}
%    \end{macrocode}
% The dynamic mode number is initialized each listing with the current `value'
%  of |\lst@newmode|.
%    \begin{macrocode}
\lst@AddToHook{InitVars}{\let\lst@dynamicmode\lst@newmode}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{User control}
%
% \begin{lstkey}{switchmode}
% Let's see how a user controls the mode settings.
% We first extract \meta{from} and \meta{to} from the first `optional' argument
%  and check for consistency.
% A single argument is moved to |\lst@type| and |\lst@arg| gets empty (which
%  corresponds to the kernel).
%    \begin{macrocode}
\lst@Key{switchmode}\relax{\lstKV@OArg[]{#1}{%
  \lstKV@ReadArgs:{\lst@arg\lst@type}{##1}%
  \let\lst@error\z@
  \unless\ifcsname\@lst if\lst@arg\endcsname \let\lst@error\@ne\fi
  \unless\ifcsname\@lst if\lst@type\endcsname \let\lst@error\@ne\fi
  \ifx\lst@type\@empty \let\lst@type\lst@arg \let\lst@arg\@empty\fi
  \ifx\lst@type\@empty \let\lst@error\tw@\fi
%    \end{macrocode}
%    \begin{macrocode}
  \ifnum\lst@error>\z@
    \lst@Error{Unknown or illegal <from> or <to> in `switchmode'}\@eha
  \else
%    \end{macrocode}
% Build some necessary control sequences and append |##2| with |\@nil| as
%  terminator.
%    \begin{macrocode}
    \expandafter\lst@SwitchMode
      \csname\@lst modeset@\lst@arg\expandafter\endcsname
      \csname\@lst\lst@type true\expandafter\endcsname
      \csname\@lst\lst@type false\expandafter\endcsname
      \csname\@lst restrict@\lst@type\endcsname
    ##2\@nil
  \fi}}
\def\lst@SwitchMode#1#2#3#4{%
  \@ifnextchar[{\lst@SwitchModeArg#1#2#3#4}%
               {\lst@SwitchModeTF#1#2#3#4}}
%    \end{macrocode}
% We remove the previous settings from |\lst@modeset@|\meta{from} by replacing
%  |#2|, |#3|, and |#4| with empty arguments.
% Then we insert an item based on the user provided value |#5|.
% That's all here.
%    \begin{macrocode}
\def\lst@SwitchModeTF#1#2#3#4#5\@nil{%
  \lst@RemoveDefFrom#1#4%
  \lst@ReplaceIn#1{\@empty#2{}#3{}#4{}}%
  \lstKV@SetIf{#5t}\lst@if
  \lst@if \lst@lAddTo#1#2\else \lst@lAddTo#1#3\fi}
%    \end{macrocode}
% If we have a second |[]|-argument, we cut it up and save the boolean value
%  |#5|.
%    \begin{macrocode}
\def\lst@SwitchModeArg#1#2#3#4[#5]#6\@nil{%
  \lstKV@SetIf{#6t}\lst@if
  \lstKV@ReadArgs:{\lst@delim\lst@classes\lst@option}{#5}%
%    \end{macrocode}
% We use either |\lst@modeset@|\meta{from} or |\lst@modesetdelim@|\meta{delim}
%  as the first argument to |\lst@SwitchModeArg@| depending on whether the
%  setting applies to a mode class or a particular delimiter.
%    \begin{macrocode}
  \ifx\lst@delim\@empty
    \lst@SwitchModeArg@#1#2#3#4%
  \else
    \let\lst@arg\@empty \expandafter\lst@RedefConvert\lst@delim\@nnil
    \expandafter\lst@SwitchModeArg@\csname\@lst modesetdelim@\lst@arg\endcsname
        #2#3#4%
  \fi}
%    \end{macrocode}
% We update any previous true/false setting after providing |#1|.
%    \begin{macrocode}
\def\lst@SwitchModeArg@#1#2#3#4{%
  \lst@ProvideDef#1{}\@empty
  \lst@RemoveDefFrom#1#4%
  \lst@ReplaceIn#1{\@empty#2{}#3{}#4{}}%
  \lst@if \lst@lAddTo#1#2\else \lst@lAddTo#1#3\fi
%    \end{macrocode}
% If we're working on an escape, we remove any |\lst@extra| definition and add
%  a new one if the user requested an escape.
% |\lst@extra| will define the begin/end escape sequences on processing.
%    \begin{macrocode}
  \ifx#2\lst@escapetrue
    \lst@RemoveDefFrom#1\lst@extra
    \lst@if
              \def\lst@temp{\def\lst@escapebegin}%
      \lst@elAddTo\lst@temp{\expandafter{\lst@classes}%
                            \def\lst@escapeend}%
      \lst@elAddTo\lst@temp{\expandafter{\lst@option}}%
      \lst@elAddTo#1{\expandafter\def\expandafter
                         \lst@extra\expandafter{\lst@temp}}%
    \fi
  \else
%    \end{macrocode}
% If we don't have an escape, the user enables or disables a family (this has
%  already be done at the beginning of this macro) and may want to restrict it
%  to some classes.
% A class list is allowed only if |\lst@|\meta{to}|@data| exists---the data
%  macro for that family.
%    \begin{macrocode}
    \lst@if
      \ifcsname\@lst\lst@type @data\endcsname
          \lst@SwitchModeList #1%
      \else
        \ifx\lst@classes\@empty\else
          \lst@Error{Class list not allowed with `\lst@type'}\@ehc
        \fi
      \fi
    \fi
  \fi}
%    \end{macrocode}
% |\lst@@SwitchModeList| will be defined at the end of section \ref{iMakingTests}.
% First we need to know more about the keyword detection.
% \end{lstkey}
%
%
% \subsection{Dropping input}\label{iDroppingInput}
%
% An internal mode is used to drop input, e.g.~to skip to the first printing
%  line.
% This mode deactivates all characters except they have been registered via
%  |\lst@RegisterEndDropInputChar|.
%
% The technical details:
% Each registered character will be made equivalent to |\lst@@EndDropInputChar|,
%  which just contains |\lst@EndDropInputChar|.
% The latter macro calls the character specific
%  |\lst@EndDropInputChar|\meta{char}.
% That way we are able to distinguish between different `end drop input'
%  charcaters.
% A local |\lst@ScanNextChar| checks whether the coming character is equivalent
%  to |\lst@@EndDropInputChar| and calls it with attached \meta{char} or drops
%  the character and continues scanning.
%
% \begin{macro}{\lst@RegisterEndDropInputChar}
% \marg{char number}\meta{save cs}\marg{new cs}
%
% Save the old meaning, assign |\lst@@EndDropInputChar|, and define the
%  character specific |\lst@EndDropInputChar|\meta{char number}.
%    \begin{macrocode}
\def\lst@RegisterEndDropInputChar#1#2{%
  \lst@LetSaveDef{#1}#2\lst@@EndDropInputChar
  \expandafter\let\csname\@lst EndListingChar\number#1\endcsname}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@@EndDropInputChar{\lst@EndDropInputChar}
%    \end{macrocode}
% Here we just call |\lst@EndDropInputChar|\meta{char number} and gobble |#2|.
%    \begin{macrocode}
\def\lst@EndDropInputChar#1#2{\csname\@lst EndListingChar\number`#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@dropinputmode}
% Entering the mode we put code on the stack to restore modified definitions.
%    \begin{macrocode}
\lst@NewMode*[]\lst@dropinputmode
\lst@AddToModeSet{\the\lst@dropinputmode}{%
  \lst@AddToStackItem{\let\lst@ScanNextChar\lst@ScanNextCharScan
                      \lst@Let{13}\lst@M@saved
                      \lst@Let{10}\lst@J@saved}%
%    \end{macrocode}
% \begin{remark}{Alternative}
% |\lst@modeset|\meta{the dropinputmode}|end| containing exactly the same code
%  could replace the usage of the stack item here.
% \end{remark}
% We save some definitions and register the EOL characters.
%    \begin{macrocode}
  \let\lst@EndDropInputChar@saved\lst@EndDropInputChar
  \lst@RegisterEndDropInputChar{13}\lst@M@saved\lst@MSkipToFirst
  \lst@RegisterEndDropInputChar{10}\lst@J@saved\lst@MSkipToFirst
%    \end{macrocode}
% When scanning a character while dropping the input, we check whether the
%  `character' equals |\lst@@EndDropInputChar|.
% If this is the case, we call the macro with the character as argument.
%    \begin{macrocode}
  \def\lst@ScanNextChar##1{%
    \expandafter\ifx\csname\@lst CT\number`##1\endcsname\lst@@EndDropInputChar
      \expandafter\lst@EndDropInputChar\expandafter##1%
    \fi
    \lst@ScanNextChar}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@MSkipToFirst}
% EOL characters will be equivalent to this definition while dropping input.
% Reaching the first line, the EOL characters defined above end the dropping,
%  inititalize variables, and start the processing.
%    \begin{macrocode}
\def\lst@MSkipToFirst{%
  \global\advance\lst@lineno\@ne
  \ifnum \lst@lineno=\lst@firstline
    \lst@LeaveMode
    \lsthk@BeginPart \lsthk@InitVarsBOL \lsthk@InitScanBOL
    \@tempcnta\lst@gobble\relax
    \expandafter\lst@BOLGobble
  \else
    \lsthk@DroppedNewline
    \expandafter\lst@ScanNextChar
  \fi}
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{DroppedNewline}{}% init
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@SkipToFirst}
% This definition actually skips to the next part of a listing.
% If we haven't reached the first line of that part, we drop the input and start
%  the scanning.
% |\lst@BOLGobble| eventually also calls |\lst@ScanNextChar|.
%    \begin{macrocode}
\def\lst@SkipToFirst{%
  \ifnum \lst@lineno<\lst@firstline
    \lst@EnterMode\lst@dropinputmode{}%
    \expandafter\lst@ScanNextChar
  \else
    \lsthk@BeginPart \lsthk@InitVarsBOL \lsthk@InitScanBOL
    \@tempcnta\lst@gobble\relax
    \expandafter\lst@BOLGobble
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{gobble}
% The key sets the number of characters to gobble each line.
%    \begin{macrocode}
\lst@Key{gobble}{0}{\def\lst@gobble{#1}}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@BOLGobble}
% Start the line scanning if the counter is/has reached zero.
%    \begin{macrocode}
\def\lst@BOLGobble{%
  \ifnum\@tempcnta=\z@ \expandafter\lst@ScanNextChar
                 \else \expandafter\lst@BOLGobble@a \fi}
%    \end{macrocode}
% We grab the first token of |\lst@CT|\meta{char number} to check against.
%    \begin{macrocode}
\def\lst@BOLGobble@a#1{%
  \expandafter\expandafter\expandafter\lst@BOLGobble@b
    \csname\@lst CT\number`#1\endcsname\@nnil\@empty#1}
%    \end{macrocode}
% The |\lowercase| prepares the insertion of spaces when gobbling a tabulator.
% If we've found |^^@|, an EOL or a form feed character, the loop is terminated
%  and we scan that character.
%    \begin{macrocode}
\begingroup\lccode`\/=`\ \lowercase{\endgroup
\gdef\lst@BOLGobble@b#1#2\@empty#3{%
  \def\lst@next{\lst@ScanNextChar#3}%
  \ifx #1\@empty\else
  \ifx #1\lst@MProcessListing\else
  \ifx #1\lst@ProcessFormFeed\else
%    \end{macrocode}
% A tabulator decreases the temporary counter by |\lst@tabsize| (and possibly
%  inserts remaining spaces if necessary), \ldots
%    \begin{macrocode}
    \let\lst@next\lst@BOLGobble
    \ifx #1\lst@Scan@tab
      \advance\@tempcnta-\lst@tabsize\relax
      \ifnum\@tempcnta<\z@
        \let\lst@temp\@empty
        \@whilenum\@tempcnta<\z@\do{\edef\lst@temp{\lst@temp/}%
                                    \advance\@tempcnta\@ne}%
        \def\lst@next{\expandafter\lst@ScanNextChar\lst@temp}%
      \fi
    \else
%    \end{macrocode}
% whereas any other (known or unknown) character decreases the counter by one.
%    \begin{macrocode}
      \ifx #1\relax \lst@Error{Undefined character \number`#3}\@ehd \fi
      \advance\@tempcnta\m@ne
    \fi
  \fi \fi \fi
  \lst@next}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Delimiters}
%
%
% \subsubsection{Escaping}
%
% \begin{macro}{\lst@ifescape}
% The escape feature is always turned off when entering a new mode.
%    \begin{macrocode}
\lst@NewModeClass{escape}{false}{false}
%    \end{macrocode}
% The user must request it explicitly or by an escape mode.
%    \begin{macrocode}
\def\lst@modeset@escape{\lst@InitModesF \lst@escapetrue}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@BeginEscape}
% The escape is not activated directly, but right before scanning the next
%  character.
%    \begin{macrocode}
\def\lst@BeginEscape{%
  \lst@modeset@escape
  \def\lst@ScanNextChar{%
%    \end{macrocode}
% We restore |\lst@ScanNextChar|, define the correct scan class, deactivate
%  low-level scanning (i.e.~all characters are just collected), \ldots
%    \begin{macrocode}
    \let\lst@ScanNextChar\lst@ScanNextCharScan
    \def\lst@scanclass{escape}%
    \lst@scanlowfalse
%    \end{macrocode}
% define |\lst@extra| to set |\lst@escapebegin|\(\vert\)|end| and eventually
%  continue the scan.
%    \begin{macrocode}
            \def\lst@extra{\def\lst@escapebegin}%
    \lst@elAddTo\lst@extra{\expandafter{\lst@escapebegin}\def\lst@escapeend}%
    \lst@elAddTo\lst@extra{\expandafter{\lst@escapeend}}%
    \lst@ScanNextCharScan}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@EndEscape}
% We only need to put the token into the stream, restore low-level scanning,
%  and deactivate the escape.
%    \begin{macrocode}
\def\lst@EndEscape{%
  \lst@AddTokenToStream \lst@scanlowtrue
  \global\let\lst@ifescape\iffalse}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@Process@escape}
% \marg{content}|{}|\marg{definition of begin/end sequences}
%
% The scanning of an escape puts this into the token stream.
% To process the characters we use |\scantokens| after restoring the catcodes,
%  inserting the begin and end material, and `unmasking' the characters via
%  |\edef|.
%    \begin{macrocode}
\def\lst@Process@escape#1#2#3{%
  \lst@OutputWhitespaces
  \begingroup
    \edef\lst@arg{#1}%
    #3%
    \lst@elAddTo\lst@escapebegin{\expandafter{\lst@arg}}%
    \lst@elAddTo\lst@escapebegin\lst@escapeend
    \lst@RestoreCatcodes
    \lst@currstyle{\scantokens\expandafter{\lst@escapebegin}}%
  \endgroup}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{escapebegin}
% \begin{lstkey}{escapeend}
% The keys simply store the arguments.
%    \begin{macrocode}
\lst@Key{escapebegin}{}{\def\lst@escapebegin{#1}}
\lst@Key{escapeend}{}{\def\lst@escapeend{#1}}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
%
%
% \subsubsection{Opening and closing}\label{iOpeningAndClosing}
%
% \begin{macro}{\lst@DelimOpen}
% We enter the specified mode, put the delimiter into |\lst@token|, apply
%  restrictions, and print the delimiter if necessary.
%    \begin{macrocode}
\def\lst@DelimOpen#1#2#3#4#5\@empty{%
  \lst@EnterMode{#3}%
  {\lst@ScanToken\lst@scan@delim{#5}%
   \ifcsname\@lst modesetdelim@\the\lst@token\endcsname
     \csname\@lst modesetdelim@\the\lst@token\expandafter\endcsname
   \fi
   #2%
   #4}%
  #1\lst@AddTokenToStream \else \lst@ResetScanClass\lst@ResetToken \fi
  \lst@ScanNextChar}
%    \end{macrocode}
% The |\lst@ScanNextChar| keeps the scanning alive.
% \end{macro}
%
% \begin{macro}{\lst@DelimClose}
% is the opposite.
% Here is the usual place for an escape to end.
%    \begin{macrocode}
\def\lst@DelimClose#1#2\@empty{%
  \lst@ifescape \lst@EndEscape \fi
  #1%
    \lst@ScanToken\lst@scan@delim{#2}%
    \lst@AddTokenToStream
  \fi
  \lst@LeaveMode
  \lst@ScanNextChar}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@CArgEmpty}
% Note that the last argument to |\lst@DelimOpen| and |\lst@DelimClose| is
%  terminated by |\@empty|.
% Therefore this macro here will come in handy when used in \meta{pre} and
%  \meta{post}, for example.
%    \begin{macrocode}
\def\lst@CArgEmpty#1\@empty{#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@BeginDelim}
% \begin{macro}{\lst@EndDelim}
% These definitions are applications of |\lst@DelimOpen| and |\lst@DelimClose|:
% the delimiters are printed and nothing special is executed at the starting
%  delimiter.
%    \begin{macrocode}
\def\lst@BeginDelim{\lst@AddTokenToStream \lst@DelimOpen\iftrue{}}
\def\lst@EndDelim{\lst@AddTokenToStream \lst@DelimClose\iftrue}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@BeginDelimInvisible}
% \begin{macro}{\lst@EndDelimInvisible}
% Another application: no delimiter is printed.
%    \begin{macrocode}
\def\lst@BeginDelimInvisible{\lst@AddTokenToStream \lst@DelimOpen\iffalse{}}
\def\lst@EndDelimInvisible{\lst@AddTokenToStream \lst@DelimClose\iffalse}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@BeginDelimDrop}
% \begin{macro}{\lst@EndDelimDrop}
% In contrast to dropping the input in section \ref{iDroppingInput}, we do not
%  disable the scanning of the characters.
% Instead the characters won't make it into the token stream by (a) escaping
%  and (b) prohibiting the insertion of token stream material here and when
%  leaving the escape.
%    \begin{macrocode}
\def\lst@BeginDelimDrop{%
  \lst@AddTokenToStream
  \lst@DelimOpen\iffalse{\lst@escapetrue \let\lst@ifaddtostream\iffalse}}
\def\lst@EndDelimDrop{\lst@DelimClose{\let\lst@ifaddtostream\iftrue \iffalse}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@BeginDelimExclude}
% \begin{macro}{\lst@EndDelimExclude}
% Here the delimiters are not part of the delimited code.
% We either scan the delimiter and enter the mode, or leave the mode and scan
%  the delimiter afterwards.
%    \begin{macrocode}
\def\lst@BeginDelimExclude#1#2#3\@empty{%
  \lst@AddTokenToStream
  \lst@ScanToken\lst@scan@delim{#3}\lst@AddTokenToStream
  \lst@EnterMode{#1}{#2}%
  \lst@ScanNextChar}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@EndDelimExclude#1\@empty{%
  \lst@AddTokenToStream
  \lst@ifescape \lst@EndEscape \fi
  \lst@LeaveMode
  #1}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsubsection{Delimiter definitions}
%
% \begin{macro}{\lst@ifdelims}
% uses the normal true/false setting (opposed to the escape feature).
%    \begin{macrocode}
\lst@NewModeClass{delims}{true}{false}
%    \end{macrocode}
% A delimiter definition with a dynamic mode looks like |\lst@UseDynamicMode|
%  |\z@|
%  |[delim]||\lst@DelimDM@s||{/*}{*/}\@empty||\lst@BeginDelim||\lst@EndDelim|
%  |{}|.
% An example with a static mode is |\lst@Comment@pod| |=\@empty|
%  |\lst@BeginDelim| |\lst@EndDelim| \marg{comment style selection}.
% \end{macro}
%
% \begin{macro}{\lst@DefDelimB}
% \begin{macro}{\lst@DefDelimE}
% Actual delimiter definitions will use these two helper macros.
% Here we put the arguments together to fit |\lst@CDef|(|AMC|).
% Note that the very last argument |\@empty| is a brake for |\lst@CArgEmpty|
%  and |\lst@DelimOpen|\(\vert\)|Close|.
%    \begin{macrocode}
\def\lst@DefDelimB#1#2#3#4{%
  \lst@CDef{#1}#2{#3}%
           {\let\lst@bnext\lst@CArgEmpty #4\lst@bnext}\@empty}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@DefDelimE#1#2#3#4{%
  \lst@CDefAMC{#1}#2{#3}%
           {\let\lst@enext\lst@CArgEmpty #4\lst@enext}\@empty}
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{Init}{\let\lst@bnext\@empty \let\lst@enext\@empty}
%    \end{macrocode}
% Please wonder about the strange use of |\lst@bnext| and |\lst@enext|.
% And notice that |#4| could change the meaning of these macros!
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@DelimDM@l}
% \begin{macro}{\lst@DelimDM@s}
% These macros will define \texttt{line} and \texttt{single} delimiters with
%  dynamic modes.
% We use |\lst@CArg| to create the necessary arguments for |\lst@CDef| in
%  |\lst@DefDelimB| and |\lst@DefDelimE|.
% Both delimiters do nothing reaching the first character of the delimiter, but
%  enter or leave the dynamic mode if the whole delimiter is found (and mode
%  changes are allowed).
% For this |\lst@bnext| and |\lst@enext| are adjusted.
%    \begin{macrocode}
\def\lst@DelimDM@l#1#2\@empty#3#4#5{%
  \lst@CArg #2\relax\lst@DefDelimB{}%
      {\lst@ifdelims \def\lst@bnext{#3{#1}{#5\lst@Lmodetrue}}\fi}}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@DelimDM@s#1#2#3\@empty#4#5#6{%
  \lst@CArg #2\relax\lst@DefDelimB{}%
      {\lst@ifdelims \def\lst@bnext{#4{#1}{#6}}\fi}%
  \lst@CArg #3\relax\lst@DefDelimE{}%
      {\ifnum #1=\lst@mode \let\lst@enext#5\fi}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{lstkey}{delim}
% \begin{macro}{\lst@DelimKey}
% The keys use |\lst@DelimKey|, \ldots
%    \begin{macrocode}
\lst@Key{delim}\relax{\lst@DelimKey\@empty{#1}}
\lst@Key{moredelim}\relax{\lst@DelimKey\relax{#1}}
\lst@Key{deletedelim}\relax{\lst@DelimKey\@nnil{#1}}
%    \end{macrocode}
% where we put together the arguments for |\lst@Delim|.
%    \begin{macrocode}
\def\lst@DelimKey#1#2{%
  \lst@Delim{}#2\relax{Delim}#1%
     {\lst@BeginDelim\lst@EndDelim}
    i{\lst@BeginDelimInvisible\lst@EndDelimInvisible}
     {\lst@BeginDelimDrop\lst@EndDelimDrop}}
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
%
% \begin{macro}{\lst@Delim}
% We define the defaults, count stars, and read optional arguments.
%    \begin{macrocode}
\def\lst@Delim#1{%
  \def\lst@style{#1}\let\lst@option\@empty
  \lstKV@ReadOArgs{\lst@type\lst@style\lst@option}\lst@Delim@}
\def\lst@Delim@#1\relax#2#3#4#5#6#7{%
%    \end{macrocode}
% A verbose and nonempty style name is converted into a control sequence.
%    \begin{macrocode}
  \ifx\lst@style\@empty\else
    \lst@DelimMakeStyleSelect\lst@style
  \fi
%    \end{macrocode}
% Now we build the tail with type and prefix specific
%  |\lst@Begin|\ldots|\lst@End|\ldots\space commands, add the style argument,
%  and put it into |\lst@style| for the moment.
% Note that prefixes are removed from |\lst@type|.
%    \begin{macrocode}
  \expandafter\lst@DelimType\lst@type\relax #5{#4}{#6}{#7}%
  \lst@elAddTo\lst@arg{\expandafter{\lst@style}}%
  \let\lst@style\lst@arg
%    \end{macrocode}
% We might need to delete a bunch of delimiters.
% The argument |#3| equals |\@empty|, |\relax|, or |\@nnil| depending on whether
%  the initial key is \keyname{delim}, \keyname{moredelim}, or
%  \keyname{deletedelim} respectively similar keys from other aspects.
%    \begin{macrocode}
  \ifx #3\@empty \lst@RedefDeleteClass{#2}\fi
%    \end{macrocode}
% If the delimiter |#1| is empty, we might delete a subclass.
%    \begin{macrocode}
  \ifx\@empty#1\@empty
    \ifx #3\@nnil
      \ifcsname\@lst #2DM@\lst@type\endcsname
        \lst@RedefDeleteClass{#2DM@\lst@type}%
      \else
        \lst@RedefDeleteClass{#2@\lst@type}%
      \fi
    \fi
  \else
%    \end{macrocode}
% If not present, we try to load the particular delimiter.
%    \begin{macrocode}
    \ifcsname\@lst #2DM@\lst@type\endcsname \else
    \ifcsname\@lst #2@\lst@type\endcsname \else
      \begingroup
      \lowercase{\lst@RequireAspects{[\lst@type]#2s}}%
      \endgroup
    \fi \fi
%    \end{macrocode}
% Dynamic mode delimiters are prefixed by |\lst@UseDynamicMode|
%  \meta{init number} |[|\meta{class}|]|.
% The content of |\lst@type| becomes a control sequence here.
%    \begin{macrocode}
    \ifcsname\@lst #2DM@\lst@type\endcsname
      \lowercase{\edef\lst@delim{\noexpand\lst@UseDynamicMode
                          \ifcase\@tempcntb \z@\or\@ne\or\tw@\else\thr@@\fi
                          [#2]}}%
      \edef\lst@type{\expandafter\noexpand\csname\@lst#2DM@\lst@type\endcsname}%
    \else\ifcsname\@lst #2@\lst@type\endcsname
      \let\lst@delim\@empty
      \edef\lst@type{\expandafter\noexpand\csname\@lst#2@\lst@type\endcsname}%
    \else
      \let\lst@delim\relax
    \fi \fi
%    \end{macrocode}
% An unknown type issues an error.
%    \begin{macrocode}
    \ifx\lst@delim\relax
      \lst@Error{#2 type `\lst@type' unknown}\@ehc
    \else
%    \end{macrocode}
% We add the type to the delimiter definition and, if present and not empty, the
%  optional \meta{type option} with its brackets.
%    \begin{macrocode}
      \lst@elAddTo\lst@delim\lst@type
      \ifx\lst@option\@empty\else
        \lst@elAddTo\lst@delim{\expandafter[\lst@option]}%
      \fi
%    \end{macrocode}
% The delimiters are converted and assigned to |\lst@arg|, which in turn is
%  added together with the already prepared tail to the delimiter definition.
%    \begin{macrocode}
      \let\lst@arg\@empty \lst@RedefConvert#1\@nnil
      \lst@elAddTo\lst@delim\lst@arg
      \lst@elAddTo\lst@delim\lst@style
%    \end{macrocode}
% Before adding or deleting the particular delimiter(s), we need to extract the
%  first delimiter from |\lst@arg| and add it to |\lst@type|---then all
%  arguments for |\lst@Redef|\ldots\ are ready.
%    \begin{macrocode}
      \expandafter\lst@Delim@farg\lst@arg\@nil
%    \end{macrocode}
% Depending on the mode |#3| we either remove or append the definition.
%    \begin{macrocode}
      \ifx #3\@nnil
        \expandafter\lst@RedefDelete\lst@type
      \else
        \expandafter\expandafter\expandafter\lst@RedefInsert
            \expandafter\lst@type\expandafter{\lst@delim}%
      \fi
    \fi
  \fi}
%    \end{macrocode}
% To add the first delimiter to |\lst@type|, we check the first token in
%  |\lst@arg| (which has already been expanded above).
% If it equals |\bgroup|, |#1| is the delimiter we're looking for.
% Otherwise it's |#1#2|.
%    \begin{macrocode}
\def\lst@Delim@farg{%
  \@ifnextchar\bgroup{\lst@true \lst@Delim@farg@}%
                     {\lst@false\lst@Delim@farg@}}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@Delim@farg@#1#2\@nil{%
  \lst@if \lst@lAddTo\lst@type{{#1}}%
    \else \lst@lAddTo\lst@type{{#1#2}}\fi}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DelimType}
% Depending on the prefixes we use |#3|, |#4|, or |#5| plus a preceding
%  |\@empty| for |\lst@arg|.
% Any prefixes are removed from the new |\lst@type|.
%    \begin{macrocode}
\def\lst@DelimType#1\relax#2#3#4#5{%
  \@ifstar{\def\lst@arg{\@empty #5}%
           \@ifnextchar#2{\edef\lst@type{\@gobbletwo#1}\lst@GobbleNil}%
                         {\edef\lst@type{\@gobble#1}\lst@GobbleNil}}%
          {\@ifnextchar#2{\def\lst@arg{\@empty #4}%
                          \edef\lst@type{\@gobble#1}\lst@GobbleNil}%
                         {\def\lst@arg{\@empty #3}%
                          \def\lst@type{#1}\lst@GobbleNil}}%
  #1\@nil}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DelimMakeStyleDef}
% If the user specifies an explicit style with \keyname{delim} or its relatives,
%  she or he can use a control sequence or a verbose name like
%  \texttt{keywordstyle42}---be careful, that's the ultimate keyword style.
% On scanning |\lst@extra| contains the style.
% Thus, an empty style is defined by assigning |\@empty| to |\lst@extra|.
%    \begin{macrocode}
\def\lst@DelimMakeStyleDef#1{%
  \ifx #1\@empty
    \def#1{\let\lst@extra\@empty}%
  \else
    \expandafter\lst@DelimMakeStyleDef@#1\@nil#1%
  \fi}
%    \end{macrocode}
% Otherwise we check the first token of the macro content.
% If it's a control sequence, we say |\def#3{\def\lst@extra{|\meta{content}|}}|.
%    \begin{macrocode}
\def\lst@DelimMakeStyleDef@#1#2\@nil#3{%
  \if\relax\noexpand#1%
    \expandafter\def\expandafter#3\expandafter{%
        \expandafter\def\expandafter\lst@extra\expandafter{#3}}%
%    \end{macrocode}
% If the requested style does not begin with a control sequence, we build the
%  control sequence and assign it via |\let|.
%    \begin{macrocode}
  \else
    \edef#3{\let\noexpand\lst@extra\expandafter\noexpand
                                   \csname\@lst#3\endcsname}%
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DelimMakeStyleSelect}
% First we convert the style (name) to a style definition/assignment.
% Then, depending on the number of stars, we use either
%  |\lst@ProcessCumulateStyle| or |\lst@ProcessSetStyle| to build the
%  style selection.
%    \begin{macrocode}
\def\lst@DelimMakeStyleSelect#1{%
  \lst@DelimMakeStyleDef#1%
  \lst@token\expandafter{#1}%
  \edef#1{\noexpand\lst@ScanSelectStyle
          \ifnum\@tempcntb>\@ne \noexpand\lst@ProcessCumulateStyle
                          \else \noexpand\lst@ProcessSetStyle \fi
          {\the\lst@token}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DelimStyle}
% TODO: REMOVE THE USAGE OF THIS MACRO IN |\lst@GetTheTagStyle| AND REMOVE THIS DEFINITION.
% If the user specifies an explicit style with \keyname{delim} or its relatives,
%  she or he can use a control sequence or a verbose name like
%  \texttt{keywordstyle42}---be careful, that's the ultimate keyword style.
% For a control sequence we use (depending on the number of stars) either
%  |\lst@ProcessCumulateStyle| or |\lst@ProcessSetStyle|.
%    \begin{macrocode}
\def\lst@DelimStyle#1#2\@nil{%
  \if\relax\noexpand#1%
    \lst@token\expandafter{\lst@style}%
    \edef\lst@style{\noexpand\lst@ScanSelectStyle
        \ifnum\@tempcntb>\@ne \noexpand\lst@ProcessCumulateStyle
                        \else \noexpand\lst@ProcessSetStyle \fi
        {\def\noexpand\lst@extra{\the\lst@token}}}%
  \else
%    \end{macrocode}
% If the requested style does not begin with a control sequence, we use |\let|
%  and build the control sequence.
%    \begin{macrocode}
    \edef\lst@style{\noexpand\lst@ScanSelectStyle
        \ifnum\@tempcntb>\@ne \noexpand\lst@ProcessCumulateStyle
                        \else \noexpand\lst@ProcessSetStyle \fi
        {\let\noexpand\lst@extra\expandafter
                                \noexpand\csname\@lst\lst@style\endcsname}}%
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ScanSelectStyle}
% \meta{style processing macro}\marg{style}
%
% It's not obvious, but style selections made by delimiters eventually appear in
%  the second argument of |\lst@EnterMode|.
% So we can use the stack item to execute things when the mode ends.
% This macro puts the style selection into the stream and adds code to recover
%  the previous style to the stack item.
%    \begin{macrocode}
\def\lst@ScanSelectStyle#1#2{%
  \lst@AddToTokenStream{#1{}{}{#2}}%
  \lst@AddToStackItem{\lst@AddToTokenStream{\lst@ProcessPopStyle{}{}{}}}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Identifier detection}
%
% \begin{lstkey}{classoffset}
% just stores the argument for use with families and classes.
%    \begin{macrocode}
\lst@Key{classoffset}\z@{\def\lst@classoffset{#1}}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@DefStyle}
% We extract a class number and add \keyname{classoffset}.
% Then check for optional stars and build |\lst@|\meta{style name}\meta{number}
%  (without number if it equals 1).
%    \begin{macrocode}
\def\lst@DefStyle#1#2{\lstKV@OArg[\@ne]{#2}{%
  \@tempcnta \numexpr##1+\lst@classoffset\relax
  \lstKV@CountStars{\expandafter\lst@DefStyle@ul
    \csname\@lst #1\ifnum\@tempcnta=\@ne\else\the\@tempcnta\fi\endcsname}%
  ##2\@nil}}
%    \end{macrocode}
% Depending on the number of stars we add nothing or some code to make the token
%  upper/lower case.
%    \begin{macrocode}
\def\lst@DefStyle@ul#1#2\@nil{%
  \ifcase\@tempcntb
        \def#1{#2}%
    \or \def#1{\uppercase\expandafter{\expandafter\lst@token
                         \expandafter{\the\lst@token}}#2}%
  \else \def#1{\lowercase\expandafter{\expandafter\lst@token
                         \expandafter{\the\lst@token}}#2}%
  \fi}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Classes and families}
%
% \begin{macro}{\lst@InstallFamily}
% Recall the parameters
% \begin{macroargs}
% \item \meta{prefix}
% \item \meta{name}
% \item \meta{style name}
% \item \meta{style init}
% \item \meta{default style name}
% \item \meta{working procedure}
% \item \alternative{l,o} (language or other key)
% \end{macroargs}
% First we define the keys and the key \meta{style name} if and only if the name
%  is not empty.
%    \begin{macrocode}
\def\lst@InstallFamily#1#2#3#4#5{%
  \lst@Key{#2}\relax{\lst@UseFamily{#2}##1\relax\lst@MakeKeywords}%
  \lst@Key{more#2}\relax{\lst@UseFamily{#2}##1\relax\lst@MakeMoreKeywords}%
  \lst@Key{delete#2}\relax{\lst@UseFamily{#2}##1\relax\lst@DeleteKeywords}%
  \ifx\@empty#3\@empty\else
    \lst@Key{#3}{#4}{\lst@DefStyle{#3}{##1}}%
  \fi
  \expandafter\lst@InstallFamily@\csname\@lst#2@data\expandafter\endcsname
                                 \csname\@lst#5\endcsname {#1}{#2}{#3}}
%    \end{macrocode}
% First we define a new mode class, add the code `|\lst@if|\meta{name} detect
%  \meta{name} |\fi|' to the \hookname{AddTokenToStream} hook, and initialize
%  the new hook \hookname{Detect@}\meta{name} for keyword detection.
%    \begin{macrocode}
\def\lst@InstallFamily@#1#2#3#4#5#6#7{%
  \lst@NewModeClass{#4}{true}{false}%
  \edef\lst@temp{{AddTokenToStream}%
                 {\expandafter\noexpand\csname\@lst if#4\endcsname
                  \expandafter\noexpand\csname lsthk@Detect@#4\endcsname
                  \noexpand\fi}}%
  \expandafter\lst@AddToHook\lst@temp
  \lst@AddToHook{Detect@#4}{}% init
%    \end{macrocode}
% Define the data macro.
%    \begin{macrocode}
  \gdef#1{{#3}{#4}{#5}#2#7}%
%    \end{macrocode}
% If \meta{working procedure} is empty, we provide a definition, which assigns
%  |\lst@|\meta{style name}\meta{number} (but omit \meta{number} if it equals
%  one).
%    \begin{macrocode}
  \long\def\lst@temp##1{#6}%
  \ifx\lst@temp\@gobble
    \global\@namedef{\@lst g#4@wp}##1{%
        \expandafter\let\expandafter\lst@extra
            \csname\@lst#5\ifnum##1=\@ne\else##1\fi\endcsname}%
  \else
    \global\@namedef{\@lst g#4@wp}##1{#6}%
  \fi}
%    \end{macrocode}
% Nothing else is defined here, all the rest is done on demand.
% \end{macro}
%
% \begin{macro}{\lst@InstallClass}
% To install just one keyword class and not a whole family, we use |[\@ne]| as
%  \meta{number} in the definitions of the keys.
%    \begin{macrocode}
\def\lst@InstallClass#1#2#3#4#5{%
  \lst@Key{#2}\relax{\lst@UseFamily{#2}[1]##1\relax\lst@MakeKeywords}%
  \lst@Key{more#2}\relax{\lst@UseFamily{#2}[1]##1\relax\lst@MakeMoreKeywords}%
  \lst@Key{delete#2}\relax{\lst@UseFamily{#2}[1]##1\relax\lst@DeleteKeywords}%
  \ifx\@empty#3\@empty\else
      \lst@Key{#3}{#4}{\lst@DefStyle{#3}{[1]##1}}%
  \fi
  \expandafter\lst@InstallFamily@\csname\@lst#2@data\expandafter\endcsname
                                 \csname\@lst#5\endcsname {#1}{#2}{#3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@UseFamily}
% We look for the optional class number and provide a default if necessary.
%    \begin{macrocode}
\def\lst@UseFamily#1{%
  \def\lst@family{#1}%
  \@ifnextchar[\lst@UseFamily@{\lst@UseFamily@[\@ne]}}
\def\lst@UseFamily@[#1]{%
  \@tempcnta\lst@classoffset \advance\@tempcnta#1\relax
  \lst@ProvideClass\lst@family{\the\@tempcnta}%
%    \end{macrocode}
% |\lst@ProvideClass| does the main work here, see below.
% Now we need to build a couple of control sequences \ldots
%    \begin{macrocode}
  \expandafter\lst@UseFamily@b
    \csname\@lst\lst@family\the\@tempcnta @list\expandafter\endcsname
    \csname\@lst\lst@family\the\@tempcnta \expandafter\endcsname
    \csname\@lst\lst@family\the\@tempcnta @also\expandafter\endcsname
    \csname\@lst g\lst@family\the\@tempcnta\endcsname}
%    \end{macrocode}
% required for |#6|\(=\)|\lst@MakeKeywords|, e.g.
%    \begin{macrocode}
\def\lst@UseFamily@b#1#2#3#4#5\relax#6{\lstKV@XOArg[]{#5}#6#1#2#3#4}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@MakeKeywords}
% This macro is eventually called in |\lst@UseFamily@b|.
% We empty some macros and make use of |\lst@MakeMoreKeywords|.
% Note that this and the next two definitions have the following arguments:
% \begin{macroargs}
% \item class list (in brackets)
% \item keyword list
% \item |\lst@|\meta{name}|@list|
% \item |\lst@|\meta{name}
% \item |\lst@|\meta{name}|@also|
% \item |\lst@g|\meta{name}
% \end{macroargs}
%    \begin{macrocode}
\def\lst@MakeKeywords[#1]#2#3#4#5#6{%
  \def#3{#4#6}\let#4\@empty \let#5\@empty
  \lst@MakeMoreKeywords[#1]{#2}#3#4#5#6}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@MakeMoreKeywords}
% We append classes and keywords.
%    \begin{macrocode}
\def\lst@MakeMoreKeywords[#1]#2#3#4#5#6{%
  \lst@BuildClassList#3#1,\relax,%
  \lst@DefKeywordList\lst@temp{#2}%
  \lst@elAddTo#4{\expandafter,\lst@temp}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@BuildClassList}
% For each \meta{item} in the list (e.g.~|keywords2,emph1,\relax,|) we
%  \emph{append} the two macros |\lst@|\meta{item}|\lst@g|\meta{item} to |#1|.
%    \begin{macrocode}
\def\lst@BuildClassList#1#2,{%
  \ifx\relax#2\@empty\else
    \ifx\@empty#2\@empty\else
      \lst@elAddTo#1{\csname\@lst #2\expandafter\endcsname
                     \csname\@lst g#2\endcsname}%
    \fi
    \expandafter\lst@BuildClassList\expandafter#1
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DefKeywordList}
% The task here is to convert all characters to character tokens (this can
%  easily be done by |\lst@DefOther|, but |\,| must not become equal to
% |,|\(_{12}\) (this can't be done with |\lst@DefOther| alone).
% Hence we split the keyword list at each |\,|, \ldots
%    \begin{macrocode}
\def\lst@DefKeywordList#1#2{%
  \let\lst@arg\@empty
  \lst@DefKeywordList@#2\,\@nnil%
  \let#1\lst@arg}
%    \end{macrocode}
% use |\lst@DefOther| for the contents in between, \ldots
%    \begin{macrocode}
\begingroup \lccode`c=`\,\lowercase{\endgroup
\def\lst@DefKeywordList@#1\,#2{%
  \lst@DefOther\lst@temp{#1}%
  \lst@elAddTo\lst@arg\lst@temp
  \ifx #2\@nnil\else
%    \end{macrocode}
% and replace |\,| by |,|\(_{11}\).
%    \begin{macrocode}
    \lst@lAddTo\lst@arg{c}%
    \expandafter\lst@DefKeywordList@\expandafter#2%
  \fi}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DeleteKeywords}
% We convert the keyword arguments via |\lst@MakeKeywords| and remove the
%  classes and keywords.
%    \begin{macrocode}
\def\lst@DeleteKeywords[#1]#2#3#4#5#6{%
  \lst@MakeKeywords[#1]{#2}\@tempa\@tempb#5#6%
  \lst@DeleteClassesIn#3\@tempa
  \lst@RemoveFromList#4\@tempb}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DeleteClassesIn}
% deletes pairs of tokens, namely the arguments |#2#3| to the submacro.
%    \begin{macrocode}
\def\lst@DeleteClassesIn#1#2{%
  \expandafter\lst@DeleteClassesIn@\expandafter#1#2\@nnil\@nnil}
\def\lst@DeleteClassesIn@#1#2#3{%
  \ifx#2\@nnil \expandafter\@gobbletwo \else
%    \end{macrocode}
% If we haven't reached the end of the class list, we define a temporary macro
%  which removes all appearances.
%    \begin{macrocode}
    \def\lst@temp##1#2#3##2{%
      \lst@lAddTo#1{##1}%
      \ifx ##2\@nnil \expandafter\@gobbletwo \fi
      \lst@temp ##2}%
    \let\@tempa#1\let#1\@empty
    \expandafter\lst@temp\@tempa#2#3\@nnil
  \fi
  \lst@DeleteClassesIn@#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProvideClass}
% provides the member |#2| (roughly speaking |\the\@tempcnta|) of the family
%  |#1|.
% We do nothing if the class already exists.
% Otherwise we expand the data macro defined in the middle of
%  |\lst@InstallFamily@|.
%    \begin{macrocode}
\def\lst@ProvideClass#1#2{%
  \@ifundefined{lstfam@#1#2}%
  {\global\@namedef{lstfam@#1#2}{}%
   \expandafter\expandafter\expandafter
     \lst@ProvideClass@\csname\@lst#1@data\endcsname{#2}}%
  {}}%
%    \end{macrocode}
% Now we have the following arguments
% \begin{macroargs}
% \item \meta{prefix}
% \item \meta{name}
% \item \meta{style name}
% \item \meta{default style macro}
% \item \alternative{l,o} (language or other key)
% \item \meta{number}
% \end{macroargs}
% We define |\lst@g|\meta{name}\meta{number}|@sty| to call
%  |\lst@g|\meta{name}|@wp| with the number as argument.
%    \begin{macrocode}
\def\lst@ProvideClass@#1#2#3#4#5#6{%
  \expandafter\xdef\csname\@lst g#2#6@sty\endcsname
  {\expandafter\noexpand\csname\@lst g#2@wp\endcsname{#6}}%
%    \end{macrocode}
% We ensure the existence of the style macro.
% This is done in the \hookname{Init} hook by assigning the default style if
%  necessary.
%    \begin{macrocode}
  \ifx\@empty#3\@empty\else
    \edef\lst@temp{{Init}{\noexpand\lst@ProvideDef\expandafter\noexpand
                          \csname\@lst#3\ifnum#6=\@ne\else#6\fi\endcsname
                          {}\noexpand#4}}%
    \expandafter\lst@AddToHook\lst@temp
  \fi
%    \end{macrocode}
% We call a submacro to do the rest.
% It requires a couple of control sequences.
%    \begin{macrocode}
  \expandafter\lst@ProvideClass@@
     \csname\@lst #2#6@list\expandafter\endcsname
     \csname\@lst #2#6\expandafter\endcsname
     \csname\@lst #2#6@also\expandafter\endcsname
     \csname\@lst g#2#6@list\expandafter\endcsname
     \csname\@lst g#2#6\expandafter\endcsname
     \csname\@lst g#2#6@sty\endcsname
     {#1}{#2}#5}
%    \end{macrocode}
% Now we have
% \begin{macroargs}
% \item |\lst@|\meta{name}\meta{number}|@list|
% \item |\lst@|\meta{name}\meta{number}
% \item |\lst@|\meta{name}\meta{number}|@also|
% \item |\lst@g|\meta{name}\meta{number}|@list|
% \item |\lst@g|\meta{name}\meta{number}
% \item |\lst@g|\meta{name}\meta{number}|@sty|
% \item \meta{prefix}
% \item \meta{name}
% \item \alternative{l,o} (language or other key)
% \end{macroargs}
% We initialize all required `variables' (at \hookname{SetLanguage}) and
%  install the test (which definition is in fact also delayed).
%    \begin{macrocode}
\def\lst@ProvideClass@@#1#2#3#4#5#6#7#8#9{%
  \gdef#1{#2#5}\global\let#2\@empty \global\let#3\@empty % init
  \gdef#4{#2#5}\global\let#5\@empty % init
  \if #9l\relax
    \lst@AddToHook{SetLanguage}{\def#1{#2#5}\let#2\@empty}%
%%TODO    \lst@AddToHook{CompileKV}{\do#1\do#2}%
  \fi
  \lst@InstallTest{#7}#1#2#4#5#6{#8}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Installing tests}
%
% \begin{macro}{\lst@InstallTest}
% The arguments are
% \begin{macroargs}
% \item \meta{prefix}
% \item |\lst@|\meta{name}|@list|
% \item |\lst@|\meta{name}
% \item |\lst@g|\meta{name}|@list|
% \item |\lst@g|\meta{name}
% \item |\lst@g|\meta{name}|@sty|
% \item \meta{name}
% \item \alternative{w,s} (working procedure or style)
% \end{macroargs}
% We just insert hook material. The tests will be inserted on demand.
%    \begin{macrocode}
\def\lst@InstallTest#1#2#3#4#5#6#7{%
  \lst@AddToHook{TrackKeywords}{\lst@TrackKeywords{#1}#2#4#6{#7}}%
  \lst@AddToHook{PostTrackKeywords}{\lst@PostTrackKeywords#2#3#4#5}}
%    \end{macrocode}
% After tracking and actually defining all keywords, \ldots
%    \begin{macrocode}
\lst@AddToHook{Init}%
  {\global\let\lst@DoDefineKeywords\@empty
   \lsthk@TrackKeywords \lsthk@PostTrackKeywords \lst@DoDefineKeywords
   \global\let\lst@DoDefineKeywords\@empty
%    \end{macrocode}
% the (globally) defined keywords have the same case as the (locally) requested
%  ones.
%    \begin{macrocode}
   \global\let\lst@ifsensitivedefed\lst@ifsensitive}
\lst@AddToHook{TrackKeywords}{}% init
\lst@AddToHook{PostTrackKeywords}{}% init
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@TrackKeywords}
% Now it gets a bit tricky.
% We expand the class list |\lst@|\meta{name}|@list| behind
%  |\lst@TK@{|\meta{prefix}|}||\lst@g|\meta{name}|@sty| and use two |\relax|es
%  as terminators.
% This will define the keywords of all the classes as keywords of type
%  \meta{prefix}.
% More details come soon.
%    \begin{macrocode}
\def\lst@TrackKeywords#1#2#3#4#5{%
  \lst@false
  \def\lst@temp{\lst@TK@{#1}#4}%
  \expandafter\lst@temp#2\relax\relax
%    \end{macrocode}
% And nearly the same to undefine all out-dated keywords.
%    \begin{macrocode}
  \def\lst@temp{\lst@TK@@{#1}#4#2}%
  \expandafter\lst@temp#3\relax\relax
%    \end{macrocode}
% Finally we install the keyword test if keywords changed, in particular if they
%  are defined the first time.
% We install a test for a family only once based on the \meta{prefix}.
% For this we redefine |\lst@KeywordTest| to check its argument against the
%  given prefix |#1|.
%    \begin{macrocode}
  \lst@if
    \begingroup
    \def\lst@arg{#1}%
    \def\lst@KeywordTest##1{\def\lst@temp{##1}%
                            \ifx\lst@arg\lst@temp \lst@false \fi}%
    \lst@UseHook{Detect@#5}%
    \lst@if \lst@AddToHook{Detect@#5}{\lst@KeywordTest{#1}}\fi
    \endgroup
  \fi}
%    \end{macrocode}
% Back to the current keywords.
% Global macros |\lst@g|\meta{id} contain globally defined keywords, whereas
%  |\lst@|\meta{id} contain the true keywords.
% This way we can keep track of the keywords:
% If keywords or \keyname{sensitive} changed, we undefine the old (= globally
%  defined) keywords and define the true ones.
% The arguments of |\lst@TK@| are
% \begin{macroargs}
% \item \meta{prefix}
% \item |\lst@g|\meta{name}|@sty|
% \item |\lst@|\meta{id}
% \item |\lst@g|\meta{id}
% \end{macroargs}
% The definition of keywords is delayed via |\lst@DoDefineKeywords|.
%    \begin{macrocode}
\def\lst@TK@#1#2#3#4{%
  \ifx\lst@ifsensitive\lst@ifsensitivedefed
    \ifx#3#4\else
      \lst@true
      \lst@UndefineKeywords{#1}#4#2%
      \lst@AddTo\lst@DoDefineKeywords{\lst@DefineKeywords{#1}#3#2}%
    \fi
  \else
    \ifx#3\relax\else
      \lst@true
      \lst@UndefineKeywords{#1}#4#2%
      \lst@AddTo\lst@DoDefineKeywords{\lst@DefineKeywords{#1}#3#2}%
    \fi
  \fi
%    \end{macrocode}
% Reaching the end of the class list, we end the loop.
%    \begin{macrocode}
  \ifx#3\relax
      \expandafter\@gobblethree
  \fi
  \lst@TK@{#1}#2}
%    \end{macrocode}
% Here now we undefine the out-dated keywords.
% While not reaching the end of the global list, we look whether the keyword
%  class |#4#5| is still in use or needs to be undefined.
% Our arguments are
% \begin{macroargs}
% \item \meta{prefix}
% \item |\lst@g|\meta{name}|@sty|
% \item |\lst@|\meta{name}|@list|
% \item |\lst@|\meta{id}
% \item |\lst@g|\meta{id}
% \end{macroargs}
%    \begin{macrocode}
\def\lst@TK@@#1#2#3#4#5{%
  \ifx#4\relax
    \expandafter\@gobblefour
  \else
    \lst@IfSubstring{#4#5}#3{}{\lst@UndefineKeywords{#1}#5#2}%
  \fi
  \lst@TK@@{#1}#2#3}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@PostTrackKeywords}
% After updating all the keywords, the global keywords and the global list
%  become equivalent to the local ones.
%    \begin{macrocode}
\def\lst@PostTrackKeywords#1#2#3#4{%
  \global\let#3#1%
  \global\let#4#2}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Making tests}\label{iMakingTests}
%
% \begin{macro}{\lst@KeywordTest}
% \marg{prefix}
%
% Here we take advance of the |\lst@UM| construction in section
%  \ref{iStandardCharacters}:
% The token expands to the original character sequence if |\lst@UM| is empty.
% Since |\lst|\meta{prefix}|@|\meta{keyword} will be equivalent to an
%  appropriate working procedure (possibly assigning a style to |\lst@extra|),
%  we only need to build the control sequence.
%    \begin{macrocode}
\def\lst@KeywordTest#1{%
  \ifcsname lst#1@\the\lst@token\endcsname
    \csname lst#1@\the\lst@token\endcsname
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@KEYWORDTEST}
% Case insensitive tests make the current character string upper case and give
%  it to a submacro similar to |\lst@KeywordTest|.
%    \begin{macrocode}
\def\lst@KEYWORDTEST{%
  \uppercase\expandafter{\expandafter\lst@KEYWORDTEST@\the\lst@token}\relax}
\def\lst@KEYWORDTEST@#1\relax#2{%
  \ifcsname lst#2@#1\endcsname
    \csname lst#2@#1\expandafter\endcsname
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DefineKeywords}
% Eventually we need macros which define and undefine
% |\lst|\meta{prefix}|@|\meta{keyword}. Here the arguments are
% \begin{macroargs}
% \item \meta{prefix}
% \item |\lst@|\meta{name} (a keyword list)
% \item |\lst@g|\meta{name}|@sty|
% \end{macroargs}
% We make the keywords upper case if necessary, \ldots
%    \begin{macrocode}
\def\lst@DefineKeywords#1#2#3{%
  \lst@ifsensitive
    \def\lst@next{\lst@for#2}%
  \else
    \def\lst@next{\uppercase\expandafter{\expandafter\lst@for#2}}%
  \fi
  \lst@next\do
%    \end{macrocode}
% \ldots\space iterate through the list, and make
% |\lst|\meta{prefix}|@|\meta{keyword} (if undefined) equivalent to
% |\lst@g|\meta{name}|@sty| which is possibly a working macro.
%    \begin{macrocode}
  {\expandafter\ifx\csname lst#1@##1\endcsname\relax
      \global\expandafter\let\csname lst#1@##1\endcsname#3%
   \fi}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@UndefineKeywords}
% We make the keywords upper case if necessary, \ldots
%    \begin{macrocode}
\def\lst@UndefineKeywords#1#2#3{%
  \lst@ifsensitivedefed
    \def\lst@next{\lst@for#2}%
  \else
    \def\lst@next{\uppercase\expandafter{\expandafter\lst@for#2}}%
  \fi
  \lst@next\do
%    \end{macrocode}
% \ldots\space iterate through the list, and `undefine'
% |\lst|\meta{prefix}|@|\meta{keyword} if it's equivalent to
% |\lst@g|\meta{name}|@sty|.
%    \begin{macrocode}
  {\expandafter\ifx\csname lst#1@##1\endcsname#3%
     \global\expandafter\let\csname lst#1@##1\endcsname\lst@undefined
   \fi}}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{sensitive}
% is a switch, preset \texttt{true} every language selection.
%    \begin{macrocode}
\lst@Key{sensitive}\relax[t]{\lstKV@SetIf{#1}\lst@ifsensitive}
\lst@AddToHook{SetLanguage}{\let\lst@ifsensitive\iftrue}
%    \end{macrocode}
%    \begin{macrocode}
\global\let\lst@ifsensitive\iftrue % init
\global\let\lst@ifsensitivedefed\iffalse % init % \global
%    \end{macrocode}
% We select case insensitive definitions if necessary.
%    \begin{macrocode}
\lst@AddToHook{Init}%
  {\lst@ifsensitive\else
     \let\lst@KeywordTest\lst@KEYWORDTEST
   \fi}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@SwitchModeList}
% There is one thing left: restricting a family to particular classes.
% The parameters here are filled by the data macro of the family.
% First we add \keyname{classoffset} to each number in |\lst@classes|.
% This is done by an expandable temporary definition.
%    \begin{macrocode}
\def\lst@SwitchModeList{%
  \def\lst@temp##1,{%
      \ifx\@empty##1\@empty\else
        \ifx\@nnil##1\expandafter\expandafter\expandafter\@gobble
        \else
          \number\numexpr \lst@classoffset+##1,
        \fi
      \fi
      \lst@temp}%
  \edef\lst@classes{\expandafter\lst@temp\lst@classes,\@nnil,}%
%    \end{macrocode}
% Build some necessary control sequence and expand the class list.
% Note that there is one more argument to read from the `parent': the mode set
%  to which the restrictions apply.
%    \begin{macrocode}
  \expandafter\lst@SwitchModeList@
      \csname\@lst restrict@\lst@type\expandafter\endcsname
      \csname\@lst g\lst@type @wp\expandafter\endcsname
      \csname\@lst g\lst@type @wp@\expandafter\endcsname
      \lst@classes\@nil}
%    \end{macrocode}
% We delete any old data from the mode set |#5|: First the definition of |#1|,
%  then the execution.
%    \begin{macrocode}
\def\lst@SwitchModeList@#1#2#3#4\@nil#5{
  \lst@RemoveDefFrom#5#1%
  \lst@ReplaceIn#5{\@empty#1{}}%
%    \end{macrocode}
% If a class list is present, we add the definition of
%  |\lst@restrict@|\meta{name} to |#5|.
% On execution (right after the definition) we save the current working
%  procedure, restore it when leaving the mode, and define a new one.
%    \begin{macrocode}
  \ifx\lst@classes\@empty\else
    \lst@lAddTo#5{\def#1{\let#3#2\lst@AddToStackItem{\let#2#3}%
                         \lst@DefRestrictWP#2#3{#4}}%
                  #1}%
  \fi}
%    \end{macrocode}
% The new working procedure |#1| defines a temporary macro to test whether the
%  current number |##1| is part of the list |#3|.
% If not, the execution of the old definition is gobbled.
%    \begin{macrocode}
\def\lst@DefRestrictWP#1#2#3{%
  \def#1##1{\def\lst@temp####1,##1,####2####3\relax{%
                \ifx\@empty####2\expandafter\@gobbletwo\fi}%
            \lst@temp,#3,##1,\@empty\relax
            #2{##1}}}
%    \end{macrocode}
% \end{macro}
%
%
% \section{Doing output}
%
%
% \subsection{Single boxes and lost space}
%
% \begin{lstkey}{basewidth}
% \begin{macro}{\lst@width}
% The key assigns the values to macros and tests whether they are negative.
%    \begin{macrocode}
\lst@Key{basewidth}{0.6em,0.45em}{
  \lstKV@ReadArgs,{\lst@widthfixed\lst@widthflexible}{#1}%
  \ifx\lst@widthflexible\@empty
     \let\lst@widthflexible\lst@widthfixed
  \fi
  \let\lst@error\z@
  \ifdim \lst@widthfixed<\z@
     \let\lst@error\@ne \let\lst@widthfixed\z@
  \fi
  \ifdim \lst@widthflexible<\z@
     \let\lst@error\@ne \let\lst@widthflexible\z@
  \fi
  \ifnum\lst@error>\z@
    \lst@Error{Negative value(s) treated as zero}\@ehc
  \fi}
%    \end{macrocode}
%    \begin{macrocode}
\newdimen\lst@width % global
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
%
% \begin{lstkey}{fontadjust}
% Since \keyname{basewidth} is usually given in font specific dimensions, we
%  need to determine the current value at \hookname{InitVars}.
% Moreover, the user can update it after style selection using the key.
%    \begin{macrocode}
\lst@Key{fontadjust}{false}[t]{\lstKV@SetIf{#1}\lst@iffontadjust}
\lst@AddToHook{FontAdjust}%
  {\global\lst@width=\lst@ifflexible\lst@widthflexible
                               \else\lst@widthfixed\fi \relax}
\lst@AddToHook{InitVars}{\lsthk@FontAdjust}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@lostspace}
% |\lst@lostspace| is the difference between the current and the desired line
%  width.
% Whenever this dimension is positive we can insert space.
% A negative `lost space' means that the printed line is wider than expected.
%    \begin{macrocode}
\newdimen\lst@lostspace % \global
\lst@AddToHook{InitProcessBOL}{\global\lst@lostspace\z@}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@OutputBoxStatic}
% \begin{macro}{\lst@OutputBoxDynamic}
% |\lst@scan@|\meta{class}\marg{contents}\marg{length}\marg{style selection}
%
% First we output preceding whitespaces including lost space.
% For static parameters we drop the class argument, whereas
%  |\lst@SetBoxParams|\meta{align}|@|\meta{class} might change the definitions
%  of |\lst@lefthss|, |\lst@righthss|, |\lst@leftspace|, |\lst@rightspace|,
%  |\lst@OutputLostSpace|, or even |\lst@FillOutputBox|.
% It thus fully controls the adjustment of the output!
%    \begin{macrocode}
\def\lst@OutputBoxStatic#1{%
  \lst@OutputWhitespaces
  \bgroup
    \lst@OutputBox@}
\def\lst@OutputBoxDynamic#1{%
  \lst@OutputWhitespaces
  \bgroup
    \csname\@lst SetBoxParams\lst@outputalign @#1\endcsname
    \lst@OutputBox@}
%    \end{macrocode}
% Here we fill |\@tempboxa| and eventually output it.
% We take care of special output styles and font adjustment.
% Yet unknown macros are defined in the following sections.
%    \begin{macrocode}
\def\lst@OutputBox@#1#2#3{%
    \setbox\@tempboxa\hbox{%
      \lst@token{#1}\lst@length#2%
      \color@begingroup
      #3{\let\lst@UM\lst@UMprint
         \lst@iffontadjust \lsthk@FontAdjust \fi
         \lst@hbox{\lst@lefthss
                   \expandafter\lst@FillOutputBox\the\lst@token\@empty
                   \lst@righthss}}
      \color@endgroup}%
    \lst@CalcLostSpaceAndOutput
  \egroup}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@CalcLostSpaceAndOutput}
% We keep track of |\lst@lostspace| and |\lst@streamlength|.
%    \begin{macrocode}
\def\lst@CalcLostSpaceAndOutput{%
  \global\advance\lst@lostspace \lst@length\lst@width
  \global\advance\lst@lostspace-\wd\@tempboxa
  \global\advance\lst@streamlength \lst@length
%    \end{macrocode}
% We insert space in front of and after |\@tempboxa| if there is enough lost
%  space.
%    \begin{macrocode}
  \lst@alloverstyle{\ifdim\lst@lostspace>\z@ \lst@leftspace \fi
                    \box\@tempboxa
                    \ifdim\lst@lostspace>\z@ \lst@rightspace \fi}%
  \lsthk@PostOutput}
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{PostOutput}{}% init
\let\lst@leftspace\@empty \let\lst@rightspace\@empty % init
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@alloverstyle}
% \begin{macro}{\lst@currstyle}
% All output boxes will go through this macro.
% In particular, it has been used a few lines above.
%    \begin{macrocode}
\def\lst@alloverstyle#1{#1}% init
\lst@AddToHook{Init}{\global\let\lst@currstyle\relax}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@Kern}
% A |\lst@alloverstyle| has been removed here.
%    \begin{macrocode}
\def\lst@Kern#1{{\lst@currstyle{\kern#1}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@UseLostSpace}
% \begin{macro}{\lst@InsertLostSpace}
% \begin{macro}{\lst@InsertHalfLostSpace}
% The first definition inserts space if and only if |\lst@lostspace| is
%  positive.
% The other two always `insert' space, even if it is negative.
%    \begin{macrocode}
\def\lst@UseLostSpace{%
  \ifdim\lst@lostspace>\z@ \lst@InsertLostSpace \fi}
\def\lst@InsertLostSpace{%
  \lst@Kern\lst@lostspace \global\lst@lostspace\z@}
\def\lst@InsertHalfLostSpace{%
  \global\lst@lostspace.5\lst@lostspace
  \lst@Kern\lst@lostspace}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \subsection{Column formats}
%
% Note: Technically both the column format and the positioning argument of the
%  \keyname{column} key can fully control the parameters of the output
%  alignment.
% But we will use the column format to set some main parameters and the
%  positioning argument to do the fine tuning.
%
% \begin{macro}{\lst@ifflexible}
% indicates the column mode, but does not distinguish between different fixed or
%  flexible modes.
%    \begin{macrocode}
\def\lst@flexibletrue{\let\lst@ifflexible\iftrue}
\def\lst@flexiblefalse{\let\lst@ifflexible\iffalse}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@column@fixed}
% switches to fixed column format.
%    \begin{macrocode}
\def\lst@column@fixed{%
  \lst@flexiblefalse
  \lst@width\lst@widthfixed\relax
  \let\lst@OutputLostSpace\lst@UseLostSpace
  \let\lst@WhitespaceLostSpace\lst@UseLostSpace
  \let\lst@FillOutputBox\lst@FillFixed
  \let\lst@hss\hss
  \let\lst@ils\lst@InsertLostSpace
  \let\lst@ihls\lst@InsertHalfLostSpace
  \def\lst@hbox{\hbox to\lst@length\lst@width}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@FillFixed}
% Filling up a fixed column box is easy.
% While not reaching the end |\@empty|, we insert dynamic space, output the
%  argument and call the submacro again.
%    \begin{macrocode}
\def\lst@FillFixed#1{\kern\z@ #1\expandafter\lst@FillFixed@\@empty}
\def\lst@FillFixed@#1{%
  \ifx\@empty#1\else \lst@hss#1\expandafter\lst@FillFixed@ \fi}
%    \end{macrocode}
% Do not remove |\kern\z@|.
% It protects any space to the left from a possible |\unskip|.
% And do not remove the |\expandafter|\ldots|\@empty| construction from
%  the first macro.
% The UTF support requires |\expandafter| after |#1|.
% \end{macro}
%
% \begin{macro}{\lst@column@flexible}
% The first flexible format.
%    \begin{macrocode}
\def\lst@column@flexible{%
  \lst@flexibletrue
  \lst@width\lst@widthflexible\relax
  \let\lst@OutputLostSpace\lst@UseLostSpace
  \let\lst@WhitespaceLostSpace\lst@OutputLostSpace
  \let\lst@FillOutputBox\@empty
  \let\lst@hss\@empty
  \let\lst@ils\lst@InsertLostSpace
  \let\lst@ihls\lst@InsertHalfLostSpace
  \let\lst@hbox\hbox}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@column@fullflexible}
% This column format inserts no lost space except at the beginning of a line.
%    \begin{macrocode}
\def\lst@column@fullflexible{%
  \lst@column@flexible
  \def\lst@OutputLostSpace{\lst@ifBOL \lst@UseLostSpace\fi}%
  \let\lst@WhitespaceLostSpace\lst@OutputLostSpace
  \let\lst@ils\@empty
  \let\lst@ihls\@empty}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@column@spaceflexible}
% This column format only inserts lost space by stretching (invisible)
% existing spaces; it does not insert lost space between identifiers
% and other characters where the original does not have a space.  It
% was suggested by Andrei Alexandrescu.
%    \begin{macrocode}
\def\lst@column@spaceflexible{%
  \lst@column@fullflexible
  \let\lst@OutputLostSpace\@empty
  \def\lst@WhitespaceLostSpace{%
    \lst@ifBOL \lst@UseLostSpace
         \else \lst@ifshowspaces\else\lst@UseLostSpace\fi \fi}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@SetBoxParams@l}
% \begin{macro}{\lst@SetBoxParams@c}
% \begin{macro}{\lst@SetBoxParams@r}
% And now the fine tuning.
% These macros set the mentioned alignment parameters for the output.
% We use |\lst@hss|, |\lst@ils|, and |\lst@ihls|.
%    \begin{macrocode}
\def\lst@SetBoxParams@l{%
  \let\lst@lefthss\@empty \def\lst@righthss{\lst@hss}%
  \let\lst@leftspace\@empty \def\lst@rightspace{\lst@ils}}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@SetBoxParams@c{%
  \def\lst@lefthss{\lst@hss}\let\lst@righthss\lst@lefthss
  \def\lst@leftspace{\lst@ihls}\def\lst@rightspace{\lst@ils}}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@SetBoxParams@r{%
  \def\lst@lefthss{\lst@hss}\let\lst@righthss\@empty
  \def\lst@leftspace{\lst@ils}\let\lst@rightspace\@empty}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@SetBoxParamsDynamic@b}
% The following definitions set parameters depending on the scan class.
% By default it centers the output.
% But: Identifiers and numbers are left aligned \emph{without} inserting any
%  space at the right.
% This can make the centering of the other classes more flexible.
%    \begin{macrocode}
\let\lst@SetBoxParamsDynamic@b\lst@SetBoxParams@c
\def\lst@SetBoxParamsDynamic@b@i{%
  \let\lst@lefthss\@empty \let\lst@righthss\@empty
  \let\lst@leftspace\@empty \let\lst@rightspace\@empty}
\let\lst@SetBoxParamsDynamic@b@n\lst@SetBoxParamsDynamic@b@i
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{columns}
% The key first checks the optional parameter.
%    \begin{macrocode}
\lst@Key{columns}\relax{\lstKV@OArg[b]{#1}{%
  \ifcsname\@lst SetBoxParams@##1\endcsname
    \def\lst@boxparams{\let\lst@OutputBox\lst@OutputBoxStatic
                       \def\lst@outputalign{@##1}}%
  \else
    \ifcsname\@lst SetBoxParamsDynamic@##1\endcsname
      \def\lst@boxparams{\let\lst@OutputBox\lst@OutputBoxDynamic
                         \def\lst@outputalign{Dynamic@##1}}%
    \else
      \PackageWarning{Listings}{Unknown alignment in `columns'}%
      \def\lst@boxparams{\let\lst@OutputBox\lst@OutputBoxDynamic
                         \def\lst@outputalign{Dynamic@b}}%
    \fi
  \fi
%    \end{macrocode}
% Set the (static part of the) box paramaters.
%    \begin{macrocode}
  \lst@boxparams
  \csname\@lst SetBoxParams\lst@outputalign\endcsname
%    \end{macrocode}
% Now we check the column format, execute it, and save all data for later use.
%    \begin{macrocode}
  \ifcsname\@lst column@##2\endcsname
    \expandafter\let\expandafter\lst@arg\csname\@lst column@##2\endcsname
    \lst@arg
    \lst@ifflexible \let\lst@columnsflexible\lst@arg
                    \let\lst@boxparamsflexible\lst@boxparams
              \else \let\lst@columnsfixed\lst@arg
                    \let\lst@boxparamsfixed\lst@boxparams \fi
  \else
    \PackageWarning{Listings}{Unknown column format `##2'}%
  \fi}}
%    \end{macrocode}
% We need to initialize the four macros |\lst@columnsflexible|, \ldots\ used
%  above.
%    \begin{macrocode}
\lstsetup{columns=[c]fixed,columns=[c]flexible}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{lstkey}{flexiblecolumns}
% We switch between the last flexible and fixed format.
%    \begin{macrocode}
\lst@Key{flexiblecolumns}{true}[t]{%
  \lstKV@SetIf{#1}\lst@ifflexible
  \lst@ifflexible \lst@columnsflexible
                  \let\lst@boxparams\lst@boxparamsflexible
            \else \lst@columnsfixed
                  \let\lst@boxparams\lst@boxparamsfixed \fi}
%    \end{macrocode}
% \end{lstkey}
%
%
% \subsection{Processing the token stream}
%
% \begin{macro}{\lst@ProcessTokenStream}
% It is easy to build a box from the current token stream.
% The |\@gobblethree| with its following empty arguments makes it
%  possible to read one stream item ahead.
%    \begin{macrocode}
\def\lst@ProcessTokenStream#1{%
  \lst@AddTokenToStream
  \setbox#1\hbox{\lsthk@ProcessTokenStream
                 \lst@tokenstream\@gobblethree{}{}{}}}
\lst@AddToHook{ProcessTokenStream}{\lsthk@InitVarsBOL \lsthk@InitProcessBOL}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Styles}
%
% Delimiters add code to the token stream to select styles.
% Here we use a stack to manage this.
% Note that the first and second arguments are dropped---all items in the token
%  stream have one command and three arguments.
%
% \begin{macro}{\lst@ProcessSetStyle}
% \begin{macro}{\lst@stylestack}
% |{}{}|\marg{style}
%
% We push the current style on a stack and redefine it.
%    \begin{macrocode}
\def\lst@ProcessSetStyle#1#2#3{%
  \lst@ProcessPushStyle{}{}\lst@currstyle
  \begingroup #3\global\let\lst@currstyle\lst@extra \endgroup}
%    \end{macrocode}
%    \begin{macrocode}
\let\lst@stylestack\@empty
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@ProcessCumulateStyle}
% |{}{}|\marg{style}
%
% Same as above, except that we extend the current style.
%    \begin{macrocode}
\def\lst@ProcessCumulateStyle#1#2#3{%
  \lst@ProcessPushStyle{}{}\lst@currstyle
  \begingroup
  #3
  \ifx\lst@currstyle\relax \global\let\lst@currstyle\lst@extra
                     \else \lst@eAddTo\lst@currstyle\lst@extra\fi
  \endgroup}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProcessPushStyle}
% \marg{}\marg{post execute}\meta{style macro}
%
% Puts the given style macro on the stack.
% But first we need to output any remaining whitespaces, see |\lst@Process@ws|
%    \begin{macrocode}
\def\lst@ProcessPushStyle#1#2#3{%
  \lst@OutputWhitespaces
  \ifx#3\relax
    \gdef\lst@stackitem{\global\let#3\relax}%
  \else
    \expandafter\gdef\expandafter\lst@stackitem\expandafter{%
        \expandafter\gdef\expandafter#3\expandafter{#3}}%
  \fi
  \lst@Push\lst@stylestack
  #2}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProcessPopStyle}
% |{}{}{}|
%
% Get an item from the stack and assign it to the current style.
%    \begin{macrocode}
\def\lst@ProcessPopStyle#1#2#3{%
  \lst@Pop\lst@stylestack
  \lst@stackitem}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProcessGetNextExtra}
% \meta{extra cs}\marg{execute}
% gets the extra argument (the third one) from the next item, assigns it to
%  the control sequence, and executes the given commands.
%
% We read the next stream item |#3#4#5#6| and do what we need to do.
% Note that it is only safe to read one item ahead.
%    \begin{macrocode}
\def\lst@ProcessGetNextExtra#1#2#3#4#5#6{%
  \def#1{#6}%
  #2#3{#4}{#5}{#6}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Basic classes}
%
% The main task here is the definition of all |\lst@Process@|\meta{class}, such
%  that |\lst@Process@i| outputs the potential identifier (or keyword),
%  |\lst@Process@n| takes care of numbers, and so on.
% There is one special case you should know.
% If we process whitespaces, say
%  |\lst@Process@ws{\lst@um|\textvisiblespace|\lst@um|\textvisiblespace|}{2}{}|,
%  we put them back into |\lst@token| and |\lst@length|.
% They are output right before we output any identifier, number, delimiter, and
%  so on, see the definition of |\lst@OutputBox| (static or dynamic).
%
% \begin{macro}{\lst@Process}
% \meta{class}\marg{style}\marg{content}\marg{length}\marg{extra}
%
% This is a base for |\lst@Process@|\meta{class} definitions.
% If \meta{extra} is not empty, it overrules \meta{style}.
%    \begin{macrocode}
\def\lst@Process#1#2#3#4#5{%
  \ifx\@empty#5\@empty
    \lst@OutputBox#1{#3}{#4}{#2}%
  \else
    \lst@OutputBox#1{#3}{#4}{#5}%
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProcessWithoutExtra}
% \meta{class}\marg{style}\marg{content}\marg{length}\marg{extra}
%
% This is another base for the |\lst@Process@|\meta{class} definitions.
% It drops \meta{extra} and passes the other arguments to |\lst@OutputBox|.
%    \begin{macrocode}
\def\lst@ProcessWithoutExtra#1#2#3#4#5{\lst@OutputBox#1{#3}{#4}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@Process@m}
% \begin{macro}{\lst@Process@n}
% \begin{macro}{\lst@Process@o}
% \begin{macro}{\lst@Process@delim}
% \begin{macro}{\lst@Process@delimopen}
% \begin{macro}{\lst@Process@delimclose}
% All insert appropriate arguments for the two definitions above.
%    \begin{macrocode}
\def\lst@Process@m{\lst@Process\lst@scan@m\lst@currstyle}
\def\lst@Process@n{\lst@Process\lst@scan@n\lst@currstyle}
\def\lst@Process@o{\lst@Process\lst@scan@o\lst@currstyle}
\def\lst@Process@delim{\lst@Process\lst@scan@delim\lst@currstyle}
\def\lst@Process@delimopen{\lst@Process\lst@scan@delimopen\lst@currstyle}
\def\lst@Process@delimclose{\lst@Process\lst@scan@delimclose\lst@currstyle}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@Process@i}
% \begin{macro}{\lst@Process@text}
% \begin{lstkey}{identifierstyle}
% Just the same as above, but \ldots
%    \begin{macrocode}
\def\lst@Process@i{\lst@Process\lst@scan@i\lst@identifierstyle}
\def\lst@Process@text{\lst@Process\lst@scan@i\lst@currstyle}
%    \end{macrocode}
% the scanning class changes from |i| to |text| if identifiers are detected.
%    \begin{macrocode}
\lst@AddToHook{AddTokenToStream}{%
  \ifx\lst@scanclass\lst@scan@i \lst@ifidentifiers\else
    \def\lst@scanclass{text}%
  \fi \fi}
%    \end{macrocode}
% Eventually the necessary mode and style key.
%    \begin{macrocode}
\lst@NewModeClass{identifiers}{true}{false}
\lst@Key{identifierstyle}{}{\def\lst@identifierstyle{#1}}
\lst@AddToHook{EmptyStyle}{\let\lst@identifierstyle\@empty}
%    \end{macrocode}
% \end{lstkey}
% \end{macro}
% \end{macro}
%
%
% \subsubsection{Whitespaces}
%
% \begin{macro}{\lst@Process@ws}
% saves the data in |\lst@token| and |\lst@length|.
% That way the processing is delayed until other characters are output.
% And this is the reason for using |\lst@OutputWhitespaces| when changing the
%  style, see |\lst@ProcessPushStyle|.
%    \begin{macrocode}
\def\lst@Process@ws#1#2#3{\lst@token{#1}\lst@length#2\relax}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@lineindent}
% \begin{macro}{\lst@ifBOL}
% |\lst@lineindent| is the width of whitespace at the beginning of a line when
%  processing (not scanning) a line.
% |\lst@ifBOL| indicates whether we are at the beginning of a line.
%    \begin{macrocode}
\lst@AddToHook{InitProcessBOL}%
  {\global\let\lst@lineindent\z@ \global\let\lst@ifBOL\iftrue}
\lst@AddToHook{PostOutput}{\global\let\lst@ifBOL\iffalse}
\global\let\lst@ifBOL\iffalse
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\lst@OutputWhitespaces}
% Here we process and output the whitespaces saved in |\lst@token|.
% The token register is expanded since it is used to process the different kinds
%  of whitespaces.
% Lost space is added as defined by the column format.
%    \begin{macrocode}
\def\lst@OutputWhitespaces{%
  \ifnum\lst@length>\z@
    \expandafter\lst@OutputWhitespaces@\expandafter{\the\lst@token}%
  \fi}
\def\lst@OutputWhitespaces@#1{%
  \setbox\@tempboxa\hbox{%
    \let\lst@OutputLostSpace\lst@WhitespaceLostSpace
    \let\lst@umspace\lst@umProcessSpace
    \lst@ResetToken \let\lst@UM\lst@UMprint
    #1\lst@OutputSpaces
    \lst@OutputLostSpace}%
  \lst@ResetToken
%    \end{macrocode}
% This resets the registers set by |\lst@Process@ws|.
% |\lst@ResetToken| inside the |\hbox| clears the registers since they are used
%  to process the whitespaces.
%
% At the beginning of a line the width of the whitespaces is stored.
%    \begin{macrocode}
  \lst@ifBOL \xdef\lst@lineindent{\the\wd\@tempboxa}\fi
%    \end{macrocode}
% Now we have to deal with line breaking and actually using the constructed box.
% If we are allowed to remove whitespace at line breaks, we use the box as
%  (third) argument to |\discretionary|.
% Otherwise we insert break points around the box, one on demand and the other
%  always---except |\lst@InsertBreakPoint| is redefined.
%    \begin{macrocode}
  \lst@ifbreakremovewhitespace
    \lst@InsertBreakPoint{\box\@tempboxa}%
  \else
    \lst@ifbreakatwhitespace \lst@InsertBreakPoint{}\fi
    \box\@tempboxa
    \lst@InsertBreakPoint{}%
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{breakatwhitespace}
% \begin{lstkey}{breakremovewhitespace}
% These keys have been used above.
%    \begin{macrocode}
\lst@Key{breakatwhitespace}{false}[t]
  {\lstKV@SetIf{#1}\lst@ifbreakatwhitespace}
\lst@Key{breakremovewhitespace}{false}[t]
  {\lstKV@SetIf{#1}\lst@ifbreakremovewhitespace}
%    \end{macrocode}
% If we are allowed to break lines after each output unit, we insert such
%  potential linebreaks.
%    \begin{macrocode}
\lst@AddToHook{PostOutput}%
  {\lst@ifbreakatwhitespace\else \lst@InsertBreakPoint{}\fi}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
%
% \begin{macro}{\lst@OutputSpaces}
% This definition flushes collected spaces.
% To avoid recursion we use the submacro |\lst@OutputBox@|.
% Note that |\bgroup| is closed there.
%    \begin{macrocode}
\def\lst@OutputSpaces{%
  \ifnum\lst@length>\z@
    \bgroup
      \edef\lst@arg{{\the\lst@token}{\the\lst@length}}%
      \expandafter\lst@OutputBox@\lst@arg\lst@currstyle
    \lst@ResetToken
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@umspace}
% \begin{macro}{\lst@outputspace}
% \begin{macro}{\lst@visiblespace}
% The first macro calls the default definition for printing a space, \ldots
%    \begin{macrocode}
\def\lst@umspace{\lst@outputspace}
\def\lst@outputspace{\ }
\def\lst@visiblespace{\lst@ttfamily{\char32}\textvisiblespace}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{lstkey}{showspaces}
% \begin{lstkey}{keepspaces}
% which is modified on user's request.
%    \begin{macrocode}
\lst@Key{showspaces}{false}[t]{\lstKV@SetIf{#1}\lst@ifshowspaces}
\lst@Key{keepspaces}{false}[t]{\lstKV@SetIf{#1}\lst@ifkeepspaces}
\lst@AddToHook{Init}%
  {\lst@ifshowspaces
     \let\lst@outputspace\lst@visiblespace
     \lst@keepspacestrue
   \fi}
\lst@NewModeClass@truefalse
    \lst@ifkeepspaces
    \lst@keepspacestrue\lst@keepspacestrue@
    \lst@keepspacesfalse\lst@keepspacesfalse@
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
%
% \begin{lstkey}{showtabs}
% \begin{lstkey}{tab}
% \begin{macro}{\textvisibletabulator}
% Keys to define if and how tabulators appear in the output.
%    \begin{macrocode}
\lst@Key{showtabs}f[t]{\lstKV@SetIf{#1}\lst@ifshowtabs}
\lst@Key{tab}{\textvisibletabulator}{\def\lst@tab{#1}}
\providecommand*\textvisibletabulator
  {\kern.06em\hbox{\vrule\@height.3ex}\hrulefill\hbox{\vrule\@height.3ex}}
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
% \end{lstkey}
%
% \begin{macro}{\lst@umProcessSpace}
% The command |\lst@um|\textvisiblespace\ expands to |\lst@UM|
%  \textvisiblespace.
% Since |\lst@OutputWhitespaces| sets |\lst@UM| to |\lst@UMprint|, this expands
%  to |\lst@um|\textvisiblespace|@|, which is defined as |\lst@umspace|.
% Easy, isn't it?
% Here now we either add the output space to the token register (so it is used
%  the third time: scanning, delaying, processing) or just advance the length.
%    \begin{macrocode}
\def\lst@umProcessSpace{%
  \lst@ifkeepspaces
    \lst@AddCharToToken\lst@outputspace
  \else
    \ifnum\lst@length>\z@
      \advance\lst@length\@ne
    \else
      \lst@AddCharToToken\lst@outputspace
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@umtabulator}
% Tabulators have been added differently to the token, namely as
%  |\lst@um|\meta{tab char} |\@gobble| \marg{length}.
% |\@gobble| ensures that our whitespaces expand to character tokens in the
%  sense of \TeX---property (2) in section \ref{iStandardCharacters}.
% If the user has requested visible tabs, we output preceding spaces
%    \begin{macrocode}
\def\lst@umtabulator#1#2{%
  \lst@ifshowtabs
    \lst@OutputSpaces
    \@tempcnta#2\relax
    \setbox\@tempboxa\hbox to\@tempcnta\lst@width
        {{\lst@currstyle{\hss\lst@tab}}}%
    \lst@CalcLostSpaceAndOutput
  \else
%    \end{macrocode}
% Otherwise a tabulator is either converted to a sequence of spaces, \ldots
%    \begin{macrocode}
    \lst@ifkeepspaces
      \@tempcnta#2\relax
      \@whilenum \@tempcnta>\z@ \do
        {\lst@umspace
         \advance\@tempcnta\m@ne}%
    \else
%    \end{macrocode}
% or we insert one space (the minimal space) and advance |\lst@length| according
%  to the \meta{length}-argument.
% The |\lst@ifkeepspaces|-distinction makes things faster, but it's not
%  necessary:
% If the tabulator always expands to a sequence of spaces, |\lst@umspace| would
%  take care of the rest.
%    \begin{macrocode}
      \lst@umspace
      \advance\lst@length#2\relax
      \advance\lst@length\m@ne
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{formfeed}
% Store the user commands.
%    \begin{macrocode}
\lst@Key{formfeed}{\bigbreak}{\def\lst@formfeed{#1}}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@ProcessFormFeed}
% A formfeed never reaches the token stream.
% It is output `directly'.
% We build (inside a |\hbox|) a |\vbox| with the formfeed content, output it,
%  and initialize and continue the scanning.
%    \begin{macrocode}
\def\lst@ProcessFormFeed{%
  \lst@OutputTokenStream
  \setbox\@tempboxa\hbox{\vbox{\hsize\lst@colwidth \lst@formfeed}}%
  \lst@AddToPageBox\@tempboxa
  \lsthk@EOL \lsthk@InitVarsBOL \lsthk@InitScanBOL
  \lst@ScanNextChar}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Shipping the token stream}
%
% \begin{macro}{\lst@ifeolisting}
% The things here and in the following depend on whether we've reached the end
%  of a listing.
%    \begin{macrocode}
\def\lst@eolistingtrue{\let\lst@ifeolisting\iftrue}
\def\lst@eolistingfalse{\let\lst@ifeolisting\iffalse}
\lst@eolistingfalse
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{print}
% If this key is (locally) set false, multiline listings will drop all the
%  output.
%    \begin{macrocode}
\lst@Key{print}{true}[t]{%
  \lstKV@SetIf{#1}\lst@ifprint
  \let\lst@ifprocessdisplay\lst@ifprint}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@OutputTokenStream}
% Process the token stream and `output' it by taking the appropriate action,
%  i.e.~consider |\lst@ifeolisting| and whether the stream is empty
%  (|\lst@ifBOL|).
% But all this is only done if printing in on.
%    \begin{macrocode}
\def\lst@OutputTokenStream{%
  \lst@ifprint
    \lst@ProcessTokenStream\@tempboxa
    \lst@ifeolisting
%    \end{macrocode}
% At the end we print empty lines and call the appropriate macro to output the
%  rest.
% Note that |\lst@AddToPageBox| eventually calls |\lst@OutputPageBox|.
%    \begin{macrocode}
      \lst@OutputEmptyLines
      \lst@ifBOL \ifvoid\lst@pagebox\else \lst@OutputPageBox \fi
           \else \lst@AddToPageBox\@tempboxa \fi
    \else
%    \end{macrocode}
% In the middle of a listing we advance the number of empty lines or output the
%  token stream.
%    \begin{macrocode}
      \lst@ifBOL
        \global\advance\lst@emptylines\@ne
      \else
        \lst@OutputEmptyLines
        \lst@AddToPageBox\@tempboxa
      \fi
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@AddToPageBox}
% \meta{hbox register containing processed token stream}
%
% A void box is added to the page box.
% Nothing more is done.
%    \begin{macrocode}
\def\lst@AddToPageBox#1{%
  \ifvoid#1%
    \lst@AddToPageBoxOnly#1%
  \else
    \lst@AddToPageBoxOnly#1%
%    \end{macrocode}
% For a nonvoid box we additionally output the material if we've reached the end
%  of a listing.
%    \begin{macrocode}
    \lst@ifeolisting
      \lst@OutputPageBox
    \else
%    \end{macrocode}
% If we're not at the end of a listing, we check whether we've enough material
%  for the current page.
% Here we don't need to take captions and frames into account since it doesn't
%  matter if we have too much material for the page.
%    \begin{macrocode}
      \ifdim \dimexpr \ht\lst@pagebox/\lst@multicols-\dp\strutbox
            >\dimexpr \lst@roomleft\relax
        \lst@OutputPageBox
      \fi
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@maxwidth}
% keeps the current width of a display listing.
%    \begin{macrocode}
\newdimen\lst@maxwidth % \global
\lst@AddToHook{InitDisplay}{\global\lst@maxwidth\z@}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@AddToPageBoxOnly}
% \begin{macro}{\lst@pagebox}
% First we update |\lst@maxwidth|.
%    \begin{macrocode}
\def\lst@AddToPageBoxOnly#1{%
  \ifdim \wd#1>\lst@maxwidth
    \global\lst@maxwidth \ifdim\lst@colwidth<\wd#1\lst@colwidth\else \wd#1\fi
  \fi
%    \end{macrocode}
% We have to put previous |\lst@pagebox| material in front of the new box |#1|.
% So we unbox it and preserve |\prevdepth|.
%    \begin{macrocode}
  \global\setbox\lst@pagebox\vbox
    {\hsize \lst@ifbox\lst@maxwidth \else\lst@colwidth \fi
     \ifvoid\lst@pagebox\else
       \@tempdima=\dp\lst@pagebox
       \unvbox\lst@pagebox
       \prevdepth=\@tempdima
     \fi
%    \end{macrocode}
% The horizontal box |#1| is |\unhbox|ed now using an appropriate parshape,
%  roughly speaking.
%    \begin{macrocode}
     \everypar{}\par\noindent
     \lst@ifbreaklines
       \lst@parshape\lsthk@EveryLine\strut\unhbox#1%
     \else
       \lsthk@EveryLine\strut\box#1%
     \fi}}
%    \end{macrocode}
%    \begin{macrocode}
\newbox\lst@pagebox
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsubsection{Empty lines}
%
% \begin{macro}{\lst@emptylines}
% The counter holds the number of accumulated empty lines.
%    \begin{macrocode}
\newcount\lst@emptylines
\lst@AddToHook{BeginPart}{\global\lst@emptylines\z@}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{emptylines}
% We check for the optional star and set |\lst@maxempty| and the switch.
%    \begin{macrocode}
\lst@Key{emptylines}\maxdimen{%
  \@ifstar{\lst@true\@tempcnta\@gobble#1\relax\lst@GobbleNil}%
          {\lst@false\@tempcnta#1\relax\lst@GobbleNil}#1\@nil
  \advance\@tempcnta\@ne
  \edef\lst@maxempty{\the\@tempcnta\relax}%
  \let\lst@ifpreservenumber\lst@if}
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{DroppedNewline}%
  {\lst@ifpreservenumber \global\advance\c@lstnumber\@ne \fi}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{lstkey}{showlines}
% lets the user control whether empty lines are printed at the end of a listing.
%    \begin{macrocode}
\lst@Key{showlines}f[t]{\lstKV@SetIf{#1}\lst@ifshowlines}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@OutputEmptyLines}
% If we've reached the end of a listing, an empty line is output only if the
%  above key is set true.
% This is done by setting |\lst@maxempty| to zero if \keyname{showlines} is off.
%    \begin{macrocode}
\def\lst@OutputEmptyLines{%
  \lst@ifeolisting \lst@ifshowlines\else \let\lst@maxempty\z@ \fi \fi
%    \end{macrocode}
% Now we take care of |\lst@maxempty| and then \ldots
%    \begin{macrocode}
  \@whilenum \lst@emptylines>\lst@maxempty \do
  {\lsthk@DroppedNewline \advance\lst@emptylines\m@ne}%
%    \end{macrocode}
% put back the line number counter by the remaining empty lines.
% Line numbers on empty lines are dropped by modifying |\lst@skipnumbers|.
%    \begin{macrocode}
  \global\advance\c@lstnumber-\lst@emptylines
  \@whilenum \lst@emptylines>\z@ \do
  {\lst@ifnumberblanklines\else \ifnum\lst@skipnumbers=\z@
     \global\advance\lst@skipnumbers-\lst@stepnumber\relax
   \fi \fi
%    \end{macrocode}
% We output a void box and update the counters.
%    \begin{macrocode}
   \lst@AddToPageBox\voidb@x
   \global\advance\lst@emptylines\m@ne
   \global\advance\c@lstnumber\@ne}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Line shape and line breaking}
%
% \begin{lstkey}{prebreak}
% \begin{lstkey}{postbreak}
% The respective material will be used inside a |\discretionary|.
%    \begin{macrocode}
\lst@Key{prebreak}{}{\def\lst@prebreak{#1}}
\lst@Key{postbreak}{}{\def\lst@postbreak{#1}}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
%
% \begin{lstkey}{breaklines}
% \begin{macro}{\lst@InsertBreakPoint}
% Depending on whether to break lines or not \ldots
%    \begin{macrocode}
\lst@Key{breaklines}{false}[t]{\lstKV@SetIf{#1}\lst@ifbreaklines}
\def\lst@InsertBreakPoint{\lst@discretionary}
%    \end{macrocode}
% we adjust some of \TeX's registers or suppress all break points.
% Note that |\lst@discretionary| in |\lst@InsertBreakPoint| reads one argument,
%  so we use |\@firstofone|.
% The values for |\raggedright| are set by hand to avoid problems with the
%  \texttt{ltugboat} class.
%    \begin{macrocode}
\lst@AddToHook{InitDisplay}%
  {\lst@ifbreaklines
     \hbadness\@M \pretolerance\@M
     \@rightskip\@flushglue \rightskip\@rightskip % \raggedright
     \leftskip\z@skip \parindent\z@
   \else
     \let\lst@InsertBreakPoint\@firstofone
   \fi}
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
%
% \begin{macro}{\lst@discretionary}
% \begin{macro}{\lst@spacekern}
% We provide appropriate arguments for |\discretionary|, in particular pre- and
%  postbreak and |#1|.
%    \begin{macrocode}
\def\lst@discretionary#1{%
  \discretionary{\let\space\lst@spacekern \lst@prebreak}%
                {\let\space\lst@spacekern \lst@postbreak}%
                {#1}}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@spacekern{\kern\lst@width}
\lst@AddToAtTop{\try@load@fontshape}{\def\space{ }}
%    \end{macrocode}
% The addition to |\try@load@fontshape| ensures that the redefinition of
%  |\space| don't show up in |.log| messages.
% \end{macro}
% \end{macro}
%
% \begin{lstkey}{breakindent}
% \begin{lstkey}{breakautoindent}
% \begin{macro}{\lst@parshape}
% We use the primitives |\hangindent| and |\hangafter| to determine the
%  parshape.
% We just need to use the correct values.
%    \begin{macrocode}
\lst@Key{breakindent}{20pt}{\def\lst@breakindent{#1}}
\lst@Key{breakautoindent}{true}[t]{\lstKV@SetIf{#1}\lst@ifbreakautoindent}
%    \end{macrocode}
%    \begin{macrocode}
\def\lst@parshape{%
  \hangindent\lst@breakindent \hangafter\@ne
  \lst@ifbreakautoindent
    \advance\hangindent\lst@lineindent\relax
  \fi}%
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
% \end{lstkey}
%
% \begin{lstkey}{linewidth}
% \begin{lstkey}{resetmargins}
% \begin{lstkey}{xleftmargin}
% \begin{lstkey}{xrightmargin}
% Some more user adjustable parameters.
%    \begin{macrocode}
\lst@Key{linewidth}\linewidth{\def\lst@linewidth{#1}}
\lst@Key{resetmargins}{false}[t]{\lstKV@SetIf{#1}\lst@ifresetmargins}
\lst@Key{xleftmargin}\z@{\def\lst@xleftmargin{#1}}
\lst@Key{xrightmargin}\z@{\def\lst@xrightmargin{#1}}
%    \end{macrocode}
% The margins become zero if we make an exact box around the listing.
%    \begin{macrocode}
\lst@AddToHook{BoxUnsafe}%
  {\let\lst@xleftmargin\z@ \let\lst@xrightmargin\z@}
%    \end{macrocode}
% At initialization we calculate the line width.
%    \begin{macrocode}
\lst@AddToHook{InitVarsDisplay}%
  {\edef\lst@linewidth{\the\dimexpr
       \lst@linewidth-\lst@xleftmargin-\lst@xrightmargin
       \lst@ifresetmargins
          +\@totalleftmargin+\rightmargin
       \fi}%
   \lst@ifresetmargins
     \if@inlabel \leavevmode\endgraf \fi
     \@totalleftmargin\z@
   \fi
%    \end{macrocode}
% \keyname{breaklines} might adjust the following default settings.
%    \begin{macrocode}
   \rightskip\z@ \leftskip\z@ \parfillskip=\z@ plus 1fil
   \let\par\@@par}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
%
% \begin{lstkey}{lineskip}
% The optional argument is used as |\parskip|, whereas \ldots
%    \begin{macrocode}
\lst@Key{lineskip}{\z@}{\lstKV@OArg[\z@]{#1}{%
  \def\lst@parskip{##1}\def\lst@lineskip{##2}}}
\lst@AddToHook{InitDisplay}%
  {\parskip\lst@parskip\relax
   \ifdim\lst@lineskip=\z@\else
%    \end{macrocode}
% the line skip is implemented by redefining |\baselinestretch|.
%    \begin{macrocode}
     \@tempdima \dimexpr 1pt+(\lst@lineskip*65536/\baselineskip)\relax
     \edef\baselinestretch{\strip@pt\@tempdima}%
     \selectfont
   \fi}
%    \end{macrocode}
% \end{lstkey}
%
%
% \subsubsection{Line numbers}
%
% \begin{lstkey}{numbers}
% The key defines |\lst@PlaceNumber| depending on the value.
%    \begin{macrocode}
\lst@Key{numbers}{none}{%
  \lstKV@SwitchCases{#1}%
  {none&\let\lst@PlaceNumber\@empty\\%
   left&\def\lst@PlaceNumber{\llap{%
            \lst@numberstyle{\thelstnumber}\kern\lst@numbersep}}\\%
   right&\def\lst@PlaceNumber{\rlap{%
            \kern\lst@colwidth \kern\lst@numbersep
            \lst@numberstyle{\thelstnumber}}}%
  }{\lst@Error{Numbers `#1' unknown}\@eha}}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{lstkey}{numberstyle}
% \begin{lstkey}{numbersep}
% \begin{lstkey}{numberblanklines}
% \begin{lstkey}{numberfirstline}
% The keys just save their arguments.
%    \begin{macrocode}
\lst@Key{numberstyle}{}{\def\lst@numberstyle{#1}}
\lst@Key{numbersep}{10pt}{\def\lst@numbersep{#1}}
\lst@Key{numberblanklines}{true}[t]{\lstKV@SetIf{#1}\lst@ifnumberblanklines}
\lst@Key{numberfirstline}{false}[t]{\lstKV@SetIf{#1}\lst@ifnumberfirstline}
%    \end{macrocode}
% \keyname{numberfirstline} is transferred to an internal variable, which is
%  used below in |\lst@PrintLineNumber|.
%    \begin{macrocode}
\lst@AddToHook{InitDisplay}{\global\let\lst@ifnumberline\lst@ifnumberfirstline}
\def\lst@numberlinetrue{\global\let\lst@ifnumberline\iftrue}
\def\lst@numberlinefalse{\global\let\lst@ifnumberline\iffalse}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
%
% \begin{macro}{\c@lstnumber}
% This counter keeps the current label number.
% It can be referenced by |\ref|.
%    \begin{macrocode}
\newcounter{lstnumber}% \global
\global\c@lstnumber\@ne % init
\lst@AddToHook{ProcessTokenStream}{\refstepcounter{lstnumber}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\thelstnumber}
% We use arabic numbers for printing line numbers.
%    \begin{macrocode}
\renewcommand*\thelstnumber{\@arabic\c@lstnumber}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\theHlstnumber}
% The default for hyper-referencing needs to be adjusted:
% It is made unique by preceding it with the listing number, which is replaced
%  by a virtual listing number |\lst@neglisting| if the listing has no caption.
%    \begin{macrocode}
\AtBeginDocument{%
    \def\theHlstnumber{\ifx\lst@@caption\@empty \lst@neglisting
                                          \else \thelstlisting \fi
                       .\thelstnumber}}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{firstnumber}
% We select the first number according to the argument.
%    \begin{macrocode}
\lst@Key{firstnumber}{auto}{%
  \lstKV@SwitchCases{#1}%
  {auto&\let\lst@firstnumber\lst@undefined\\%
   last&\let\lst@firstnumber\c@lstnumber
  }{\def\lst@firstnumber{#1}}}
%    \end{macrocode}
% If |\lst@firstnumber| is (still) undefined when starting initialization, it
%  will use the internal line number of the listing.
%    \begin{macrocode}
\lst@AddToHook{InitVarsDisplay}%
  {\ifx\lst@firstnumber\lst@undefined \def\lst@firstnumber{\lst@lineno}\fi}
%    \end{macrocode}
% Every part of a listing we set the counter.
% It is stepped backward here since |\refstepcounter| advances it.
%    \begin{macrocode}
\lst@AddToHook{BeginPart}%
  {\global\c@lstnumber\lst@firstnumber
   \global\advance\c@lstnumber\m@ne}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{lstkey}{stepnumber}
% The key checks for a proper value.
%    \begin{macrocode}
\lst@Key{stepnumber}{1}{%
  \@tempcnta#1\relax
  \ifnum\@tempcnta<\z@ \lst@Error{Illegal value `#1' in stepnumber}\@ehc
                 \else \edef\lst@stepnumber{\the\@tempcnta}\fi}
\lst@AddToHook{EmptyStyle}{\let\lst@stepnumber\@ne}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@skipnumbers}
% We calculate how many lines must skip their line number:
% |\lst@skipnumbers| is a nonpositive representative for `first line number
%  \(\bmod\) |\lst@stepnumber|'.
% This relation holds the whole (part of the) listing.
%    \begin{macrocode}
\newcount\lst@skipnumbers % \global
\lst@AddToHook{BeginPart}
  {\ifnum \lst@stepnumber>\z@
     \global\lst@skipnumbers\lst@firstnumber
     \global\divide\lst@skipnumbers\lst@stepnumber
     \global\multiply\lst@skipnumbers-\lst@stepnumber
     \global\advance\lst@skipnumbers\lst@firstnumber\relax
     \ifnum\lst@skipnumbers>\z@
       \global\advance\lst@skipnumbers-\lst@stepnumber\relax
     \fi
%    \end{macrocode}
% If |\lst@stepnumber| is zero, no line numbers are printed:
%    \begin{macrocode}
   \else
     \let\lst@PrintLineNumber\@empty
   \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@PrintLineNumber}
% |\lst@skipnumbers| advances at the end of this macro every line.
% If that counter is/reaches zero, a line number is to be printed and we
%  decrement the counter by |\lst@stepnumber| for the next printed line number.
%    \begin{macrocode}
\def\lst@PrintLineNumber{%
  \ifnum\lst@skipnumbers=\z@
    \lst@numberlinetrue
    \global\advance\lst@skipnumbers-\lst@stepnumber\relax
  \fi
%    \end{macrocode}
% A line gets its numbner here.
% Note that |\lst@ifnumberline| could be set true just above or once via
%  |\lst@ifnumberfirstline|.
%    \begin{macrocode}
  \lst@ifnumberline
    \lst@PlaceNumber
    \lst@numberlinefalse
  \fi
  \global\advance\lst@skipnumbers\@ne}%
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{EveryLine}{\lst@PrintLineNumber}%
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Page building}
%
% Here now we split the collected lines into columns if necessary.
% Moreover we have to take care of floats and prepare frames.
% Altogether `page building' is not precise but suggestive.
%
% \begin{lstkey}{multicols}
% The key just checks for a proper argument.
%    \begin{macrocode}
\lst@Key{multicols}{1}{%
  \@tempcnta=0#1\relax
  \ifnum\@tempcnta>\z@
    \edef\lst@multicols{\the\@tempcnta}%
  \else
    \lst@Error{`#1' not allowed for `multicols'}\@eha
  \fi}
%    \end{macrocode}
% Calculate the column width.
%    \begin{macrocode}
\lst@AddToHook{InitDisplay}%
  {\edef\lst@colwidth{\the\dimexpr
       (\lst@linewidth-\lst@columnsep*\numexpr \lst@multicols-\@ne\relax)
       /\lst@multicols}}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{lstkey}{columnsep}
% \begin{lstkey}{columnsepleft}
% \begin{lstkey}{columnsepright}
% \begin{lstkey}{columnseprule}
% \begin{lstkey}{columnseprulecolor}
% These keys (mainly) save the arguments.
%    \begin{macrocode}
\lst@Key{columnsep}{\columnsep}{\def\lst@columnsep{#1}}
\lst@Key{columnsepleft}{}{\def\lst@columnsepleft{#1}\let\lst@columnsep\@empty}
\lst@Key{columnsepright}{}{\def\lst@columnsepright{#1}\let\lst@columnsep\@empty}
\lst@Key{columnseprule}{\columnseprule}{\def\lst@columnseprule{#1}}
\lst@Key{columnseprulecolor}{}{\def\lst@columnseprulecolor{#1}}
%    \end{macrocode}
% We either provide the left and right distance if necessary or we calculate
%  their values.
% Note that |\lst@columnsep| gets valued before the linewidth is calculated
%  above.
%    \begin{macrocode}
\lst@AddToHook{InitVarsDisplay}%
  {\ifnum\lst@multicols>\@ne
     \ifx\lst@columnsep\@empty
       \ifx\lst@columnsepleft\@empty \let\lst@columnsepleft\z@ \fi
       \ifx\lst@columnsepright\@empty \let\lst@columnsepright\z@ \fi
       \edef\lst@columnsep{\the\dimexpr \lst@columnsepleft+\lst@columnsepright
                                        +\lst@columnseprule}%
     \else
       \edef\lst@columnsepleft{\the\dimexpr
                                   (\lst@columnsep-\lst@columnseprule)/2}%
       \let\lst@columnsepright\lst@columnsepleft
     \fi
   \else
     \let\lst@columnsep\z@
   \fi}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
%
% \begin{lstkey}{float}
% \begin{lstkey}{floatplacement}
% A star as the first character (possibly in |\lst@floatplacement| \ldots
%    \begin{macrocode}
\lst@Key{float}\relax[\lst@floatplacement]{%
  \edef\lst@float{#1}%
  \def\lst@next{\@ifstar{\lst@true\lst@Float}{\lst@false\lst@Float}}%
  \expandafter\lst@next\lst@float\@nil}
\def\lst@Float#1\@nil{%
%    \end{macrocode}
% let us use the commands for double column floats.
% Otherwise we use the normal |\@float| and |\end@float|.
%    \begin{macrocode}
  \lst@if \let\lst@beginfloat\@dblfloat
          \let\lst@endfloat\end@dblfloat
    \else \let\lst@beginfloat\@float
          \let\lst@endfloat\end@float
  \fi
%    \end{macrocode}
% The verbose values set both |\lst@floatdefault| and |\lst@float|.
% A nonfloating listing uses |\relax|.
%    \begin{macrocode}
  \lstKV@SwitchCases{#1}%
  {true&\let\lst@floatdefault\lst@floatplacement
        \let\lst@float\lst@floatdefault\\%
   false&\let\lst@floatdefault\relax
         \let\lst@float\lst@floatdefault
%    \end{macrocode}
% Other values use either |\lst@floatplacement| or the actual characters.
%    \begin{macrocode}
  }{\ifx\@empty#1\@empty \let\lst@float\lst@floatplacement
                   \else \def\lst@float{#1}\fi}}
%    \end{macrocode}
% |\lst@floatdefault| has been set `above' as default value for the
%  \hookname{PreSet} hook.
% The construction prevents |\lstsetup| to define a default and make all
%  listings float via |float=|\meta{placement}.
% Instead one needs to use \keyname{floatplacement} and then |float=true|.
%    \begin{macrocode}
\lst@AddToHook{PreSet}{\let\lst@float\lst@floatdefault}
\let\lst@floatdefault\relax % init
\lst@Key{floatplacement}{tbp}{\def\lst@floatplacement{#1}}
%    \end{macrocode}
% The float type |\ftype@lstlisting| is set according to whether the
%  \packagename{float} package is loaded and whether \texttt{figure} and
%  \texttt{table} floats are defined.
% This is done at |\begin{document}| to make the code independent of the order
%  of package loading.
%    \begin{macrocode}
\AtBeginDocument{%
\@ifundefined{c@float@type}%
    {\edef\ftype@lstlisting{\ifx\c@figure\@undefined 1\else 4\fi}}
    {\edef\ftype@lstlisting{\the\c@float@type}%
     \addtocounter{float@type}{\value{float@type}}}%
}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
%
% \begin{macro}{\lst@iffinalchunk}
% This switch indicates whether we need to output the final decoration and
%  bottom caption, for example.
% It is not equivalent to |\lst@eolisting|:
% We could have reached the end, whereas the final chunk goes to the next page.
%    \begin{macrocode}
\def\lst@finalchunktrue{\let\lst@iffinalchunk\iftrue}
\def\lst@finalchunkfalse{\let\lst@iffinalchunk\iffalse}
\lst@finalchunkfalse
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@OutputPageBox}
% After getting the listing box we output it if it's nonvoid.
% Otherwise we get more of the listing before this macro is called again.
%    \begin{macrocode}
\def\lst@OutputPageBox{%
  \lst@BuildFinalListingBox\@tempboxa\z@
  \ifvoid\@tempboxa\else \expandafter\lst@OutputPageBox@ \fi}
%    \end{macrocode}
% Here we put together the boxes, which are possibly enclosed in a float.
%    \begin{macrocode}
\def\lst@OutputPageBox@{%
  \ifx\lst@float\relax\else
    \edef\lst@next{\noexpand\lst@beginfloat{lstlisting}[\lst@float]}%
    \expandafter\lst@next
  \fi
  \vbox{%
    \offinterlineskip
    \box\lst@topbox
    \moveright\if@twoside \ifodd\c@page\lst@xleftmargin\else\lst@xrightmargin\fi
                    \else \lst@xleftmargin \fi
              \box\@tempboxa
    \lst@iffinalchunk \box\lst@finalbox
                \else \box\lst@botbox \fi}%
  \ifx\lst@float\relax
    \ifvoid\lst@pagebox\else \newpage \fi
  \else
    \expandafter\lst@endfloat
  \fi
%    \end{macrocode}
% Some things like frames and captions might need update after each chunk is
%  output.
%    \begin{macrocode}
  \lsthk@EOPUpdate
%    \end{macrocode}
% If we haven't output the final chunk, but have reached the end of the listing,
%  we call this macro again.
% In that case a void pagebox issues a warning.
%    \begin{macrocode}
  \lst@iffinalchunk\else
    \let\lst@next\@empty
    \lst@ifeolisting
      \ifvoid\lst@pagebox
        \PackageWarning{Listings}{Bad page break\on@line}%
      \else
        \lst@BuildFinalListingBox\@tempboxa\z@
        \let\lst@next\lst@OutputPageBox@
      \fi
    \fi
    \expandafter\lst@next
  \fi}
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{EOPUpdate}{}% init
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@BuildFinalListingBox}
% \meta{box}\marg{height malus}
%
% We calculate the height we're splitting at and set the box with decoration
%  and (multicolumn) listing.
%    \begin{macrocode}
\def\lst@BuildFinalListingBox#1#2{%
  \lst@CalcSplitHt{#2}%
  \ifdim \lst@splitht=\z@
    \setbox#1\box\voidb@x
  \else
    \setbox#1=\hbox{%
      \splittopskip=\ht\strutbox \splitmaxdepth\z@ \vbadness=\@M
      \lst@AddDecoration
      \lst@SplitPageBox}%
%    \end{macrocode}
% Depending on the desired baseline we possibly lower/raise the box.
%    \begin{macrocode}
    \setbox#1=\hbox{%
      \if t\lst@boxpos
        \lower\dimexpr \ht#1-\ht\strutbox\relax
      \else \if b\lst@boxpos
        \raise\dimexpr \dp#1-\dp\strutbox\relax
      \else \if c\lst@boxpos
        \lower\dimexpr (\ht#1-\ht\strutbox+\dp\strutbox)/2\relax
      \fi \fi \fi
      \box#1}%
%    \end{macrocode}
% We add height and depth for top and bottom decoration.
%    \begin{macrocode}
    \ht#1\dimexpr \ht#1+\ht\lst@topdecorbox\relax
    \dp#1\dimexpr \dp#1+\lst@iffinalchunk \dp\lst@finaldecorbox
                                    \else \dp\lst@botdecorbox \fi \relax
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{boxpos}
% sets the vertical alignment used above.
%    \begin{macrocode}
\lst@Key{boxpos}{c}{\def\lst@boxpos{#1}}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@SplitPageBox}
% We split off one column and \ldots
%    \begin{macrocode}
\def\lst@SplitPageBox{%
  \vsplit\lst@pagebox to\lst@splitht
  \@tempcnta\lst@multicols\relax
%    \end{macrocode}
% while there is still a column to come, we output the column seperator, \ldots
%    \begin{macrocode}
  \@whilenum \@tempcnta>\@ne \do
  {\kern\lst@columnsepright
   \color@begingroup
     \lst@columnseprulecolor \vrule\@width\lst@columnseprule
   \color@endgroup
   \kern\lst@columnsepleft
%    \end{macrocode}
% warn if the column is empty, and split the pagebox.
%    \begin{macrocode}
   \ifvoid\lst@pagebox
     \PackageWarning{Listings}{Empty column in multicolumn listing}%
   \fi
   \vsplit\lst@pagebox to\lst@splitht
   \advance\@tempcnta\m@ne}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@AddDecoration}
% We raise the top decoration to its place, use final or bottom decoration, and
%  the (background) decoration for the listing.
% Then we set width, depth and height and output the box.
%    \begin{macrocode}
\def\lst@AddDecoration{%
  \setbox\z@=\hbox{%
    \raise\lst@splitht\copy\lst@topdecorbox
    \lst@iffinalchunk
      \copy\lst@finaldecorbox
    \else
      \copy\lst@botdecorbox
    \fi
    \color@begingroup \lst@decoration \color@endgroup}%
  \wd\z@\z@ \dp\z@\z@ \ht\z@\lst@splitht \box\z@}
%    \end{macrocode}
%    \begin{macrocode}
\newbox\lst@topdecorbox
\newbox\lst@botdecorbox
\newbox\lst@finaldecorbox
\lst@AddToHook{InitVarsDisplay}
  {\setbox\lst@topdecorbox\box\voidb@x
   \setbox\lst@botdecorbox\box\voidb@x
   \setbox\lst@finaldecorbox\box\voidb@x
   \let\lst@decoration\@empty}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@CalcSplitHt}
% We calculate the height of the first (and possibly single) column in the case
%  that no restrictions apply (like the remaining space on the page).
% For that we (try to) determine the line count\(-1\) of the material, divide it
%  by the number of columns, and get the line count\(-1\) of the first column.
% |-\baselineskip/2| lets us round up since we add the half of baseline skip:
% line count minus 1 alone would mean subtracting a baseline skip.
%    \begin{macrocode}
\def\lst@CalcSplitHt#1{%
  \@tempdima\dimexpr \ht\lst@pagebox+\dp\lst@pagebox\relax
  \ifnum \lst@multicols>\@ne
    \@tempcnta\numexpr \dimexpr(\@tempdima-\baselineskip)
                               /\baselineskip\relax \relax
    \divide\@tempcnta \lst@multicols\relax
    \@tempdima\dimexpr \@tempcnta\baselineskip+\baselineskip\relax
  \fi
  \lst@splitht\@tempdima
%    \end{macrocode}
% We will compare our first choice to the remaining space minus the space for
%  top and final captions and decorations.
%    \begin{macrocode}
  \@tempdimb\dimexpr \lst@roomleft-\ht\lst@topbox-\dp\lst@topbox
                                  -\ht\lst@topdecorbox-#1\relax
  \ifdim \lst@splitht>\dimexpr \@tempdimb-\ht\lst@finalbox-\dp\lst@finalbox
                                         -\dp\lst@finaldecorbox\relax
%    \end{macrocode}
% If there is not enough room, we determine the number of lines\(-1\) that fit
%  on the page when replacing the final captions and decorations by the bottom
%  ones.
% Here we use |-\baselineskip/2*3| to round down.
%    \begin{macrocode}
    \@tempcnta\numexpr \dimexpr(\@tempdimb-\ht\lst@botbox-\dp\lst@botbox
                                -\dp\lst@botdecorbox-\baselineskip/2*3)
                               /\baselineskip\relax \relax
    \ifnum\@tempcnta<\z@ \@tempcnta\z@ \fi
    \lst@splitht\dimexpr \@tempcnta\baselineskip+\baselineskip\relax
%    \end{macrocode}
% If |\lst@pagebox| is actually smaller, we adjust |\lst@splitht|.
%    \begin{macrocode}
    \ifdim\dimexpr \ht\lst@pagebox+\dp\lst@pagebox<\lst@splitht
      \lst@splitht\dimexpr \ht\lst@pagebox+\dp\lst@pagebox\relax
    \fi
    \lst@finalchunkfalse
  \else
    \lst@finalchunktrue
  \fi
%    \end{macrocode}
% Now we apply |\lst@xsplitht| and |\lst@adjustsplit|.
%    \begin{macrocode}
  \advance\lst@splitht\lst@xsplitht\relax
  \lst@adjustsplit
  \ifdim \lst@splitht>\z@
%    \end{macrocode}
% Some info, which will be removed for release. ^^A TODO
%    \begin{macrocode}
\lst@Info\z@{CalcSplitHt info
^^J current listing:\the\dimexpr\ht\lst@pagebox+\dp\lst@pagebox\relax
^^J pagespace left :\the\dimexpr\lst@roomleft\relax
^^J column split at:\the\lst@splitht}%
%    \end{macrocode}
% If there is not enough room for any listing, we start a new page and possibly
%  calculate a new split height.
%    \begin{macrocode}
  \else
    \newpage \lst@splitht\z@
    \lst@ifeolisting \lst@CalcSplitHt{#1}\fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{xsplitht}
% \begin{lstkey}{adjustsplit}
% \begin{macro}{\lst@splitht}
% The height is added to |\lst@splitht| and \keyname{adjustsplit} is executed
%  before the listing is split into columns.
%    \begin{macrocode}
\lst@Key{xsplitht}{\z@}{\def\lst@xsplitht{#1}}
\lst@Key{adjustsplit}{}{\def\lst@adjustsplit{#1}}
\newdimen\lst@splitht
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
% \end{lstkey}
%
%
% \section{Typesetting listings}
%
%
% \begin{lstkey}{basicstyle}
% This key just defines the two basic styles.
%    \begin{macrocode}
\lst@Key{basicstyle}{}{\lstKV@OArg[#1]{#1}{%
  \def\lst@basicstyleinline{##1}\def\lst@basicstyle{##2}}}
%    \end{macrocode}
% \end{lstkey}
%
%
% \subsection{Listings inside arguments}
%
% \begin{macro}{\lst@InsideConvert}
% We utilize |\scantokens|, but have to take care of:
% (a) remove inserted spaces after control sequences and (b) remove the
%  escapechar |\| from |\\|, |\{|, |\}|, |\%|, |\#| and |\ |.
% We locally make the EOL characters and the specials other, but keep the
%  backslash as escapechar.
% This is vital for the conversion.
% We start (and end) a loop inside |\xdef| on the rescanned tokens.
% Finally we add the result to |\lst@arg|.
%    \begin{macrocode}
\long\def\lst@InsideConvert#1{%
  \begingroup
  \let\do\@makeother \do\^^M\do\^^J\dospecials
  \catcode`\@11\catcode`\\\z@
  \xdef\@gtempa{\expandafter\lst@InsideConvert@loop
                \scantokens{#1\lst@InsideConvert@end}}%
  \endgroup
  \lst@elAddTo\lst@arg\@gtempa}
%    \end{macrocode}
% The loop first checks whether we've reached the end and executes this
%  definition in that case.
% Note that the control sequence after |\ifx#1| is just the terminator inside
%  |\scantokens| above.
% It could be any other control sequence.
%    \begin{macrocode}
\begingroup \lccode`\/=`\ \lowercase{\endgroup
\gdef\lst@InsideConvert@loop#1{%
  \ifx#1\lst@InsideConvert@end
    \expandafter\lst@InsideConvert@end
  \else
%    \end{macrocode}
% If we haven't reached the end, we check for |#1| being a control sequence.
% If true, we either insert a space, remove a leading backslash (if
%  |\lst@rem@bs@|\meta{control sequence} exists) or call a submacro, which
%  removes unwanted spaces after control sequences.
%    \begin{macrocode}
    \if\relax\noexpand#1%
      \ifcsname\@lst rembs@\string#1\endcsname
        \ifx#1\ /\else \expandafter\@gobble\string#1\fi
      \else
        \expandafter\lst@InsideConvert@testspace\string#1\@nil
      \fi
    \else
%    \end{macrocode}
% If the token is not a control sequence, we just leave it unexpanded, and we
%  eventually continue the loop.
%    \begin{macrocode}
      \noexpand#1%
    \fi
    \expandafter\lst@InsideConvert@loop
  \fi}%
}
%    \end{macrocode}
% The parameter text here and also the replacement text is somewhat
%  \ldots\ unconventional.
% From the loop macro above the parameter |#4| here together with the remaining
%  parameter text gobbles all tokens upto the last |\fi|.
% First we insert three |\fi|s to drop out of the conditionals and insert the
%  control sequence as a string.
%    \begin{macrocode}
\def\lst@InsideConvert@testspace#1#2#3\@nil#4\lst@InsideConvert@loop\fi{%
      \fi
    \fi
  \fi
  #1#2#3%
%    \end{macrocode}
% We lookup the catcode of the character following the backslash (in the catcode
%  table, not the catcode attached to the character).
% If it's a letter, we have a `normal' control sequence and need to remove an
%  inserted space.
% Otherwise, e.g.~having |\"|, we just continue.
% Note: The space after |=11| must not be removed---it finishes the number.
%    \begin{macrocode}
  \ifnum\the\catcode`#2=11 \expandafter\lst@InsideConvert@remspace
                     \else \expandafter\lst@InsideConvert@loop \fi}
%    \end{macrocode}
% Note that we need to remove spaces of catcode 12.
% So we read the next token and compare it against a catcode 12 space.
% If present, we remove it by not re-inserting it.
%    \begin{macrocode}
\begingroup\lccode`\/=`\ \lowercase{\endgroup
\def\lst@InsideConvert@remspace#1{%
  \if#1/\expandafter\lst@InsideConvert@loop
   \else\expandafter\lst@InsideConvert@loop \expandafter#1\fi}%
}
%    \end{macrocode}
% The conversion loop is terminated by gobbling |^^M| (inserted by
%  |\scantokens|) and preventing a \texttt{File ended while scanning definition}
%  error by issuing a |\noexpand|.
%    \begin{macrocode}
\def\lst@InsideConvert@end#1{\noexpand}
%    \end{macrocode}
% The exsistence of the following definitions let us remove the leading
%  backslash from the respective control sequence.
%    \begin{macrocode}
\@namedef{\@lst rembs@\string\\}{}
\@namedef{\@lst rembs@\string\{}{}
\@namedef{\@lst rembs@\string\}}{}
\@namedef{\@lst rembs@\string\%}{}
\@namedef{\@lst rembs@\string\#}{}
\@namedef{\@lst rembs@\string\ }{}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Inline listings}\label{iInlineListings}
%
%
% \subsubsection{Processing inline listings}
%
% \begin{macro}{\lst@InitInline}
% For initialization of inline listings we need to call some hooks, enter the
%  processing mode, and select the character table.
% Of course, in a sensible order.
%    \begin{macrocode}
\def\lst@InitInline{%
  \lsthk@Init \lsthk@InitVars \lst@basicstyleinline
  \lst@EnterMode\lst@Pmode{}%
  \lst@SelectCharTable
  \lsthk@InitVarsBOL\lsthk@InitScanBOL}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DeInitInline}
% To finish (actually start finishing) an inline listing we only need to process
%  the token stream and unbox the used box.
%    \begin{macrocode}
\def\lst@DeInitInline{%
  \lst@ProcessTokenStream\@tempboxa \unhbox\@tempboxa
  \lst@LeaveModeTo\lst@nomode}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstinline}
% After setting up some parameters, we check the delimiter.
% Allowed `values' are |\bgroup| for |{}|-delimited code and a usual character.
%    \begin{macrocode}
\newcommand\lstinline[1][]{%
  \leavevmode\bgroup
    \KV@lst@flexiblecolumns{t}\lstsetup{#1}%
%    \end{macrocode}
% |{}|-delimited code is put into |\lst@token| after initialization.
% In particular the character table selection preserves/tries to preserve as
%  many characters as possibly by assigning suitable catcodes.
% For the token assignment we need the group braces (only the closing one, the
%  other already got its catcode).
% So we restore them.
%    \begin{macrocode}
    \@ifnextchar\bgroup{\lst@InitInline \catcode`\{\@ne \catcode`\}\tw@
                        \afterassignment\lst@InlineT \lst@token}%
%    \end{macrocode}
% For a usual delimiter we use |\lst@InlineD|, \ldots
%    \begin{macrocode}
                       {\lst@InitInline \lst@InlineD}}
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{PreSet}{}% init
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@InlineD}
% which defines a temporary macro to put all characters up to |#1| into
%  |\lst@token| and call |\lst@InlineT|.
%    \begin{macrocode}
\def\lst@InlineD#1{%
  \def\lst@temp##1#1{\lst@token{##1}\lst@InlineT}%
  \lst@temp}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@InlineT}
% We convert the content of |\lst@token| (and put it into |\lst@arg|) and empty
%  the token.
%    \begin{macrocode}
\def\lst@InlineT{%
  \let\lst@arg\@empty
  \expandafter\lst@InsideConvert\expandafter{\the\lst@token}%
  \lst@token{}%
%    \end{macrocode}
% EOL within an inline listing produces an error message.
%    \begin{macrocode}
  \lst@Def{13}{\lst@DeInitInline\egroup
               \lst@Error{lstinline ended by EOL}\@ehc
               \lst@InlineE}%
%    \end{macrocode}
% We expand the inline code, start the scanning, interrupt it with |^^@|, and
%  end it.
%    \begin{macrocode}
  \expandafter\lst@ScanNextChar\lst@arg^^@\lst@DeInitInline\egroup}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@InlineE}
% After an error message we re-insert the code up to |^^@|.
%    \begin{macrocode}
\def\lst@InlineE#1^^@\lst@DeInitInline\egroup{\scantokens{#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Short inline listing environments}
%
% The implementation in this section is based on the \packagename{shortvrb}
% package, which is part of |doc.dtx| from the Standard \LaTeX\ documentation
% package, version 2006/02/02 v2.1d.  Portions of it are thus copyright
% 1993--2006 by The \LaTeX3 Project and copyright 1989--1999 by Frank
% Mittelbach.
%
% \begin{macro}{\lstMakeShortInline}
% \begin{macro}{\lstMakeShortInline@}
% First, we supply an optional argument if it's omitted.
%    \begin{macrocode}
\newcommand\lstMakeShortInline[1][]{\lstMakeShortInline@{\lstinline[#1]}}
\def\lstMakeShortInline@#1#2{%
  \expandafter\ifx\csname lst@ShortInlineOldCatcode\string#2\endcsname\relax
    \lst@shortlstinlineinfo{Made }{#2}%
    \lst@add@special{#2}%
%    \end{macrocode}
% The character's current catcode is stored in
% |\lst@ShortInlineOldCatcode\|\meta{c}.
%    \begin{macrocode}
    \expandafter
    \xdef\csname lst@ShortInlineOldCatcode\string#1\endcsname{\the\catcode`#2}%
%    \end{macrocode}
% The character is spliced into the definition using the same trick as
% used in |\verb| (for instance), having activated |~| in a group.
%    \begin{macrocode}
    \begingroup
      \lccode`\~`#2%
      \lowercase{%
%    \end{macrocode}
% The character's old meaning is recorded
% in |\lst@ShortInlineOldMeaning\|\meta{c} prior to assigning it a new one.
%    \begin{macrocode}
        \global\expandafter\let
          \csname lst@ShortInlineOldMeaning\string#1\endcsname~%
          \expandafter\gdef\expandafter~\expandafter{#1#2}}%
    \endgroup
%    \end{macrocode}
% Finally the character is made active.
%    \begin{macrocode}
    \global\catcode`#2\active
%    \end{macrocode}
% If we suspect that \meta{c} is already a short reference, we tell
% the user. Now he or she is responsible if anything goes wrong\,\dots
% (Change in \packagename{listings}: We give a proper error here.)
%    \begin{macrocode}
  \else
    \lst@Error{\string\lstMakeShorterInline\ definitions cannot be nested}%
              {Use \string\lstDeleteShortInline first.}%
    {}%
  \fi}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\lstDeleteShortInline}
%    \begin{macrocode}
\def\lstDeleteShortInline#1{%
  \expandafter\ifx\csname lst@ShortInlineOldCatcode\string#1\endcsname\relax
    \lst@Error{#1 is not a short reference for \string\lstinline}%
              {Use \string\lstMakeShortInline first.}%
    {}%
  \else
    \lst@shortlstinlineinfo{Deleted }{#1 as}%
    \lst@rem@special{#1}%
    \global\catcode`#1\csname lst@ShortInlineOldCatcode\string#1\endcsname
    \global \expandafter\let%
      \csname lst@ShortInlineOldCatcode\string#1\endcsname \relax
    \ifnum\catcode`#1=\active
      \begingroup
        \catcode`\~\active  \lccode`\~`#1%
        \lowercase{%
          \global\expandafter\let\expandafter~%
          \csname lst@ShortInlineOldMeaning\string#1\endcsname}%
      \endgroup
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@shortlstinlineinfo}
%    \begin{macrocode}
\def\lst@shortlstinlineinfo#1#2{%
     \PackageInfo{Listings}{%
       #1\string#2 a short reference for \string\lstinline}}
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\lst@add@special}
% This helper macro adds its argument to the
% |\dospecials| macro which is conventionally used by verbatim macros
% to alter the catcodes of the currently active characters.  We need
% to add |\do\|\meta{c} to the expansion of |\dospecials| after
% removing the character if it was already there to avoid multiple
% copies building up should |\lstMakeShortInline| not be balanced by
% |\lstDeleteShortInline| (in case anything that uses |\dospecials|
% cares about repetitions).
%    \begin{macrocode}
\def\lst@add@special#1{%
  \lst@rem@special{#1}%
  \lst@AddTo\dospecials{\do #1}%
%    \end{macrocode}
% Similarly we have to add |\@makeother\|\meta{c} to |\@sanitize|
% (which is used in things like "\index" to re-catcode all special
% characters except braces).
%    \begin{macrocode}
  \lst@AddTo\@sanitize{\@makeother #1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\lst@rem@special}
% The inverse of |\lst@add@special| is slightly trickier.  |\do| is
% re-defined to expand to nothing if its argument is the character of
% interest, otherwise to expand simply to the argument.  We can then
% re-define |\dospecials| to be the expansion of itself.  The space
% after |=`##1| prevents an expansion to |\relax|!
%    \begin{macrocode}
\def\lst@rem@special#1{%
  \def\do##1{%
    \ifnum`#1=`##1 \else \noexpand\do\noexpand##1\fi}%
  \xdef\dospecials{\dospecials}%
%    \end{macrocode}
% Fixing |\@sanitize| is the same except that we need to re-define
% |\@makeother| which obviously needs to be done in a group. 
%    \begin{macrocode}
  \begingroup
    \def\@makeother##1{%
      \ifnum`#1=`##1 \else \noexpand\@makeother\noexpand##1\fi}%
    \xdef\@sanitize{\@sanitize}%
  \endgroup}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Line ranges}
%
% \begin{macro}{\lst@lineno}
% The line counter counts the input lines.
% It is not directly related to the printed line numbers---think of
%  \keyname{firstnumber} or continued listings.
%    \begin{macrocode}
\newcount\lst@lineno % \global
\lst@AddToHook{InitDisplay}{\global\lst@lineno\@ne}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{firstline}
% \begin{lstkey}{lastline}
% \begin{lstkey}{linerange}
% The user keys save the arguments.
%    \begin{macrocode}
\lst@Key{firstline}\relax{\def\lst@firstline{#1\relax}}
\lst@Key{lastline}\relax{\def\lst@lastline{#1\relax}}
\lst@Key{linerange}\relax{\lstKV@OArg[]{#1}{%
  \def\lst@interrange{##1}\def\lst@linerange{##2,}}}
%    \end{macrocode}
% These keys are restricted to induvidual listings:
%    \begin{macrocode}
\lst@AddToHook{PreSet}
  {\def\lst@firstline{1}\def\lst@lastline{9999999}%
   \let\lst@linerange\@empty}
%    \end{macrocode}
% If the range list is empty, we use the first and last line to make one item.
%    \begin{macrocode}
\lst@AddToHook{InitDisplay}%
  {\ifx\lst@linerange\@empty
     \edef\lst@linerange{{\lst@firstline}-{\lst@lastline},}%
   \fi
   \lst@GetLineInterval}
\lst@AddToHook{Init}{\global\let\lst@DefRange\@empty}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
%
% \begin{macro}{\lst@MProcessListing}
% This is what we have to do at EOL while processing a listing.
% First we end line mode if necessary, which possibly ends an escape.
% If an escape is (still) active, we add a newline char to the token.
% Otherwise we process and output the token stream and update variables.
%    \begin{macrocode}
\begingroup\catcode`\^^M=12\relax%
\gdef\lst@MProcessListing{%
  \lst@AddTokenToStream%
  \lst@ifLmode \lst@LeaveMode \fi%
  \lst@ifescape%
    \lst@AddCharToToken{^^M}%
    \lst@streamlength-\lst@length% TODO: move it to hook?
    \lsthk@DroppedNewline%
  \else%
    \lst@OutputTokenStream%
    \lsthk@EOL \lsthk@InitVarsBOL \lsthk@InitScanBOL%
  \fi%
%    \end{macrocode}
% If we've reached the last line, we get the next line interval.
% The responsible macro defines |\lst@next| to do the correct next operation.
%    \begin{macrocode}
  \global\advance\lst@lineno\@ne%
  \ifnum \lst@lineno>\lst@lastline%
    \lst@GetNextLineInterval%
    \expandafter\lst@next%
  \else%
    \@tempcnta\lst@gobble\relax%
    \expandafter\lst@BOLGobble%
  \fi}%
\endgroup
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{EOL}{}% init
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@GetNextLineInterval}
% We define an appropriate |\lst@next| to either end the listing or to skip to
%  the next part.
%    \begin{macrocode}
\def\lst@GetNextLineInterval{%
  \ifx\lst@linerange\@empty
    \let\lst@next\lst@EndProcessListing
    \global\let\lst@DefRange\@empty
  \else
    \lst@interrange
    \lst@GetLineInterval
    \let\lst@next\lst@SkipToFirst
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@GetLineInterval}
% We get the first interval from |\lst@linerange|, adjust that definition, and
%  read the first and last line, which are separated by |-|.
% The terminator |-\@nnil| ensures that we are able to distinguish several
%  cases.
%    \begin{macrocode}
\def\lst@GetLineInterval{\expandafter\lst@GLI\lst@linerange\@nil}
\def\lst@GLI#1,#2\@nil{%
  \def\lst@linerange{#2}%
  \lstKV@ReadArgs-{\lst@firstline\lst@lastline}{#1-\@nnil}%
%    \end{macrocode}
% If the range is given by line numbers, we replace `empty' numbers by values.
%    \begin{macrocode}
  \lst@IfNumbers\lst@firstline\lst@lastline
  {\ifx\lst@firstline\@empty \def\lst@firstline{1}\fi
   \ifx\lst@lastline\@empty
     \def\lst@lastline{9999999}%
   \else
%    \end{macrocode}
% If only one number without a following |-| is given (i.e.~|\lst@lastline|
%  contains |\@nnil|), we need to set the last line.
%    \begin{macrocode}
     \expandafter\ifx\expandafter\@nnil\lst@lastline
       \let\lst@lastline\lst@firstline
     \fi
   \fi
%    \end{macrocode}
% We add |\relax| to the line numbers.
%    \begin{macrocode}
   \edef\lst@firstline{\lst@firstline\relax}%
   \edef\lst@lastline{\lst@lastline\relax}%
  }{%
%    \end{macrocode}
% If the range is given by marker, we add prefix and suffix to the begin-marker.
%    \begin{macrocode}
          \let\lst@rangebegin\lst@rangebeginprefix
   \lst@eAddTo\lst@rangebegin\lst@firstline
   \lst@eAddTo\lst@rangebegin\lst@rangebeginsuffix
%    \end{macrocode}
% Now we have the same cases as above with line numbers:
% The end-marker is missing (but not the separator |-|), \ldots
%    \begin{macrocode}
   \ifx\lst@lastline\@empty
     \let\lst@rangeend\@empty
   \else
     \let\lst@rangeend\lst@rangeendprefix
%    \end{macrocode}
% only one marker is given, or both.
% |\lst@rangeend| is defined accordingly.
%    \begin{macrocode}
     \expandafter\ifx\expandafter\@nnil\lst@lastline
       \lst@eAddTo\lst@rangeend\lst@firstline
     \else
       \lst@eAddTo\lst@rangeend\lst@lastline
     \fi
     \lst@eAddTo\lst@rangeend\lst@rangeendsuffix
   \fi
%    \end{macrocode}
% For general markers we set the first and last line.
% |\lst@DefRange| will be executed near the end of |\lst@SelectCharTable| and
%  installs the range detection.
%    \begin{macrocode}
   \ifx\lst@rangebegin\@empty
     \let\lst@firstline\@ne
     \global\let\lst@DefRange\lst@DefRangeEnd
   \else
     \let\lst@firstline\maxdimen
     \global\let\lst@DefRange\lst@DefRangeBegin
   \fi
   \let\lst@lastline\maxdimen}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DefRangeBegin}
% Actually defining the marker is similar to |\lst@DefDelimB|---except that we
%  unfold the first parameter and define |#1| directly instead of using
%  |\lst@CDef|.
%    \begin{macrocode}
\def\lst@DefRangeBegin{\expandafter\lst@CArg\lst@rangebegin\relax\lst@RangeB}
\def\lst@RangeB#1#2{\lst@RangeB@#1#2}
\def\lst@RangeB@#1#2#3#4{%
  \def\lst@RangeBegin{%
      \lst@IfNextChars{#2#3}%
%    \end{macrocode}
% We update |\lst@DefRange|, such that all current charaters can be restored
%  simply by |\lst@SelectCharTable|
%    \begin{macrocode}
      {\global\let\lst@DefRange\lst@DefRangeEnd
%    \end{macrocode}
% For printed range markers we leave the drop mode on recognizing the marker and
%  initialize variables.
% We also restore the meaning of |#1| and scan the marker |#1#2#3|.
%    \begin{macrocode}
       \lst@ifincluderangemarker
         \lst@LeaveMode
         \lsthk@BeginPart \lst@Let{`#1}#4\lst@DefRangeEnd
         \def\lst@next{\lst@ScanNextChar#1#2#3}%
         \expandafter\lst@next
       \else
%    \end{macrocode}
% If the marker should not be printed, we have to leave the drop mode at EOL.
% This is done by assigning the necessary line number to |\lst@firstline|.
% A possibly declared end marker is defined at leaving drop mode by adding
%  |\lst@DefRangeEnd| to the topmost item of the mode stack.
%    \begin{macrocode}
         \@tempcnta\lst@lineno \advance\@tempcnta\@ne
         \edef\lst@firstline{\the\@tempcnta\relax}%
         \lst@Let{`#1}#4%
         \lst@Pop\lst@modestack
         \lst@AddToStackItem{\lst@DefRangeEnd}%
         \lst@Push\lst@modestack
         \expandafter\lst@ScanNextChar
       \fi}%
%    \end{macrocode}
% If we haven't found the beginning, we need to check whether the old definition
%  of |#1| equals |\lst@EndDropInputChar|.
% We either use that definition or drop the character and continue the scanning.
%    \begin{macrocode}
      {\ifx #4\lst@EndDropInputChar
         \let\lst@next#4%
       \else
         \let\lst@next\lst@ScanNextChar
       \fi
       \expandafter\lst@next\lst@eaten}}%
  \lst@RegisterEndDropInputChar{`#1}#4\lst@RangeBegin}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@DefRangeEnd}
% The end marker is defined if and only if it's not empty.
%    \begin{macrocode}
\def\lst@DefRangeEnd{%
  \ifx\lst@rangeend\@empty\else
    \expandafter\lst@CArg\lst@rangeend\relax\lst@RangeE
  \fi}
\def\lst@RangeE#1#2{\lst@RangeE@#1#2}
\def\lst@RangeE@#1#2#3#4{%
  \lst@Def{`#1}{%
      \lst@IfNextChars{#2#3}%
      {\lst@ifincluderangemarker
         #4#2#3^^@\lst@OutputTokenStream
         \lst@ResetTokenStream \lsthk@EOL
       \fi
       \lst@Let{`#1}#4%
       \lst@LeaveModeTo\lst@Pmode
       \lst@GetNextLineInterval
       \expandafter\lst@DefRange
       \lst@next}%
      {\expandafter#4\lst@eaten}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{rangeprefix}
% \begin{lstkey}{rangesuffix}
% \begin{lstkey}{rangebeginprefix}
% \begin{lstkey}{rangebeginsuffix}
% \begin{lstkey}{rangeendprefix}
% \begin{lstkey}{rangeendsuffix}
% \begin{lstkey}{includerangemarker}
% These range options save their arguments and have already been used.
%    \begin{macrocode}
\lst@Key{rangeprefix}\relax{\def\lst@rangebeginprefix{#1}%
                            \def\lst@rangeendprefix{#1}}
\lst@Key{rangesuffix}\relax{\def\lst@rangebeginsuffix{#1}%
                            \def\lst@rangeendsuffix{#1}}
\lst@Key{rangebeginprefix}{}{\def\lst@rangebeginprefix{#1}}
\lst@Key{rangebeginsuffix}{}{\def\lst@rangebeginsuffix{#1}}
\lst@Key{rangeendprefix}{}{\def\lst@rangeendprefix{#1}}
\lst@Key{rangeendsuffix}{}{\def\lst@rangeendsuffix{#1}}
\lst@Key{includerangemarker}{t}[t]{\lstKV@SetIf{#1}\lst@ifincluderangemarker}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
%
% \begin{macro}{\lst@IfNumbers}
% |\lst@firstline| |\lst@lastline|
%
% The service macro is used in |\lst@GetLineInterval| to distinguish line
%  numbers from range markers.
% We check the expanded first token of the expansion of |#1| and |#2|---if they
%  are not empty.
%    \begin{macrocode}
\def\lst@IfNumbers#1#2{%
  \let\lst@next\@firstoftwo
  \ifx\@empty#1\else
    \expandafter\expandafter\expandafter\lst@IfNumber@#1\@nil
  \fi
  \ifx\@empty#2\else
    \expandafter\expandafter\expandafter\lst@IfNumber@#2\@nil
  \fi
  \lst@next}
%    \end{macrocode}
% If that token's character code does not belong to a digit, we adjust
%  |\lst@next|.
%    \begin{macrocode}
\def\lst@IfNumber@#1#2\@nil{%
  \ifnum`#1<48\relax \let\lst@next\@secondoftwo \else
  \ifnum`#1>57\relax \let\lst@next\@secondoftwo
  \fi\fi}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Environments}
%
%
% \subsubsection{Processing environments}
%
% \begin{macro}{\lst@DroppedWarning}
% gives a warning if characters have been dropped.
%    \begin{macrocode}
\def\lst@DroppedWarning{%
  \ifx\lst@dropped\@undefined\else
    \PackageWarning{Listings}{Text dropped after begin of listing}%
  \fi}
\let\lst@dropped\@undefined % init
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProcessEnv}
% We execute |\lst@ProcessEnvM| or |\lst@ProcessEnvJ| according to whether we
%  find an active EOL or a nonactive |^^J|.
%    \begin{macrocode}
\begingroup \lccode`\~=`\^^M\lowercase{%
\gdef\lst@ProcessEnv#1{%
  \ifx~#1%
    \lst@DroppedWarning \let\lst@next\lst@ProcessEnvM
  \else\ifx^^J#1%
    \lst@DroppedWarning \let\lst@next\lst@ProcessEnvJ
  \else
    \let\lst@dropped#1\let\lst@next\lst@ProcessEnv
  \fi \fi
  \lst@next}%
}\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProcessEnvJ}
% This macro deals with the case of a listing environment inside an argument.
% We need to get all listing characters and distinguish the cases `command
%  fashion' and `true environment'.
%    \begin{macrocode}
\def\lst@ProcessEnvJ{%
  \@tempcnta\lst@gobble \advance\@tempcnta\@ne
  \edef\lst@gobble{\the\@tempcnta}%
  \def\lst@arg{ }%
  \ifx\@currenvir\lst@envname
    \expandafter\lst@ProcessEnvJEnv
  \else
%    \end{macrocode}
% The first case is pretty simple:
% The code is terminated by |\end|\meta{name of environment}.
% Thus we expand that control sequence before defining a temporary macro, which
%  gets the listing and starts the scanning.
% We just need to call the temporary macro after expanding |\fi|.
%    \begin{macrocode}
    \expandafter\def\expandafter\lst@temp\expandafter##\expandafter1%
                                         \csname end\lst@envname\endcsname
        {\lst@InsideConvert{##1}\lst@ProcessEnvScan}%
    \expandafter\lst@temp
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProcessEnvJEnv}
% The environment case is more complicated.
% We get all characters up to an |\end| and the following argument.
% If that equals |\lst@envname|, we have found the end of environment.
%    \begin{macrocode}
\def\lst@ProcessEnvJEnv#1\end#2{%
  \def\lst@temp{#2}%
  \ifx\lst@envname\lst@temp
    \lst@InsideConvert{#1}%
    \expandafter\lst@ProcessEnvScan
  \else
%    \end{macrocode}
% Otherwise we convert all read characters and look for the end again.
%    \begin{macrocode}
    \lst@InsideConvert{#1\end{#2}}%
    \expandafter\lst@ProcessEnvJEnv
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProcessEnvM}
% In this case the catcodes of any coming |\|, |{|, and |}| equal 12.
% We just create the appropriate end environment string (environment or command
%  fashion) \ldots
%    \begin{macrocode}
\def\lst@ProcessEnvM{%
  \ifx\@currenvir\lst@envname
    \begingroup\lccode`\/=\escapechar\lccode`\[=`\{\lccode`\]=`\}%
    \lowercase{\endgroup
      \edef\lst@temp{/end[\lst@envname]}}%
  \else
    \begingroup\lccode`\/=\escapechar\lowercase{\endgroup
    \edef\lst@temp{/end\lst@envname}}%
  \fi
%    \end{macrocode}
% and define a temporary macro, which gets the content and starts the scanning.
%    \begin{macrocode}
  \expandafter\def\expandafter\lst@temp\expandafter##\expandafter1\lst@temp
      {\def\lst@arg{##1}\lst@ProcessEnvScan}%
  \lst@temp}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProcessEnvScan}
% Expand the content behind |\lst@SkipToFirst| and terminate it with |^^@| if
%  the listing is printed.
% Finally we end the environment.
%    \begin{macrocode}
\def\lst@ProcessEnvScan{%
  \lst@ifprocessdisplay
    \expandafter\lst@SkipToFirst\lst@arg^^@%
  \fi
  \lst@ProcessEnvEnd}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ProcessEnvEnd}
% We call the `end environment' macro using |\end| or directly as a command.
%    \begin{macrocode}
\def\lst@ProcessEnvEnd{%
  \ifx\@currenvir\lst@envname
    \edef\lst@next{\noexpand\end{\lst@envname}}%
  \else
    \def\lst@next{\csname end\lst@envname\endcsname}%
  \fi
  \lst@next}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Defining environments}
%
% \begin{macro}{\lstnewenvironment}
% Now comes the main command.
% We define undefined environments only.
% On the parameter text |#1#2#| (in particular the last sharp) see the paragraph
%  following exercise 20.5 on page 204 of `The \TeX book'.
%    \begin{macrocode}
\lst@UserCommand\lstnewenvironment#1#2#{%
  \@ifundefined{#1}%
  {\lstnewenvironment@{#1}{#1}{#2}}%
  {\lst@Error{Environment `#1' already defined}\@eha
   \@gobbletwo}}
\def\lstnewenvironment@#1#2#3#4#5{%
  \begingroup
%    \end{macrocode}
% A lonely `end environment' produces an error.
%    \begin{macrocode}
  \global\@namedef{end#2}{\lst@Error{Extra \string\end#2}\@eha}%
%    \end{macrocode}
% The `main' environment macro defines the environment name for later use and
%  calls a submacro to get all arguments.
% We open a group and make EOL active.
% This ensures |\@ifnextchar[| not to read characters of the listing---it reads
%  the active EOL instead.
%    \begin{macrocode}
  \global\@namedef{#2}{\def\lst@envname{#2}%
      \bgroup \lst@setcatcodes \catcode\active=\active
      \csname#2@\endcsname}%
%    \end{macrocode}
% The submacro is defined via |\new@command|.
% We misuse |\l@ngrel@x| to make the definition |\global| and refine \LaTeX's
%  |\@xargdef|.
%    \begin{macrocode}
  \let\l@ngrel@x\global
  \let\@xargdef\lstenv@xargdef
  \expandafter\new@command\csname#2@\endcsname#3%
%    \end{macrocode}
% `First' we execute |#4|=\meta{begin code}.
%    \begin{macrocode}
      {\let\lst@insertargs\@empty
       \lsthk@PreSet #4%
%    \end{macrocode}
% Then we have to work on ending the listing:
% (a) locally redefine `end environment' since ending is legal now and
% (b) define |\lst@EndProcessListing| to gobble all characters up to
%  |^^@|---see the definition of |\lst@ProcessEnvScan| above---for the case of
%  prematurely ending a listing.
%    \begin{macrocode}
       \@namedef{end#2}{\lst@ExitDisplay #5\egroup
                        \@doendpe \@ignoretrue}%
       \def\lst@EndProcessListing####1^^@{}%
%    \end{macrocode}
% Finally we start the processing.
%    \begin{macrocode}
       \lst@InitDisplay
       \expandafter\lst@ProcessEnv\lst@insertargs}%
  \endgroup}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstenv@xargdef}
% This is a derivation of \LaTeX's |\@xargdef|.
% We expand the submacro's name, use |\gdef| instead of |\def|, and our own a
%  kind of |\@protected@testopt|.
%    \begin{macrocode}
\def\lstenv@xargdef#1{
  \expandafter\lstenv@xargdef@\csname\string#1\endcsname#1}
\def\lstenv@xargdef@#1#2[#3][#4]#5{%
  \@ifdefinable#2%
  {\gdef#2{\ifx\protect\@typeset@protect \expandafter\lstenv@testopt
                                   \else \@x@protect#2\fi
           #1{#4}}%
   \@yargdef#1\tw@{#3}{#5}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstenv@testopt}
% The difference between this macro and |\@testopt| is that we temporaryly reset
%  the catcode of the EOL character |^^M| to read the optional argument.
%    \begin{macrocode}
\long\def\lstenv@testopt#1#2{%
  \@ifnextchar[{\catcode\active10\relax \lstenv@testopt@#1}%
               {#1[{#2}]}}
\def\lstenv@testopt@#1[#2]{\catcode\active\active #1[#2]}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{lstlisting}
% The definition is quite easy now.
% We test whether the user has given the name argument, set the keys, and deal
%  with continued line numbering.
%    \begin{macrocode}
\lstnewenvironment{lstlisting}[2][]
    {\lst@TestEOLChar{#2}%
     \lstsetup{#1}%
     \lst@SetFirstNumber}
    {\lst@SaveFirstNumber}
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\lst@TestEOLChar}
% Here we test for the two possible EOL characters.
%    \begin{macrocode}
\begingroup \lccode`\~=`\^^M\lowercase{%
\gdef\lst@TestEOLChar#1{%
  \def\lst@insertargs{#1}%
  \ifx ~#1\@empty \else
  \ifx^^J#1\@empty \else
    \global\let\lst@intname\lst@insertargs
    \let\lst@insertargs\@empty
  \fi \fi}
}\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@SetFirstNumber}
% We define the label number of the first printing line here.
%    \begin{macrocode}
\def\lst@SetFirstNumber{%
  \ifx\lst@firstnumber\lst@undefined
    \ifcsname lstno@\lst@intname\endcsname
      \edef\lst@firstnumber{%
          \the\numexpr \csname lstno@\lst@intname\endcsname\relax}%
      \lst@nololtrue
    \fi
  \fi}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@SaveFirstNumber}
% The current label is stored in|\lstno@|\meta{name}.
% If the name is empty, we use a space instead, which leaves |\lstno@|
%  undefined.
%    \begin{macrocode}
\def\lst@SaveFirstNumber{%
  \expandafter\xdef
  \csname lstno\ifx\lst@intname\@empty @ \else @\lst@intname\fi\endcsname
      {\the\c@lstnumber}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{The input command}\label{iTheInputCommand}
%
% \begin{macro}{\lst@MakePath}
% \begin{lstkey}{inputpath}
% The macro appends a slash to a path if necessary.
%    \begin{macrocode}
\def\lst@MakePath#1{\ifx\@empty#1\@empty\else\lst@MakePath@#1/\@nnil/\fi}
\def\lst@MakePath@#1/{#1/\lst@MakePath@@}
\def\lst@MakePath@@#1/{%
  \ifx\@nnil#1\expandafter\@gobble
        \else \ifx\@empty#1\else #1/\fi \fi
  \lst@MakePath@@}
%    \end{macrocode}
% Now we can empty the path or use |\lst@MakePath|.
%    \begin{macrocode}
\lst@Key{inputpath}{}{\edef\lst@inputpath{\lst@MakePath{#1}}}
%    \end{macrocode}
% \end{lstkey}
% \end{macro}
%
% \begin{macro}{\lstinputlisting}
% inputs the listing or asks the user for a new filename.
%    \begin{macrocode}
\def\lstinputlisting{%
  \begingroup \lst@setcatcodes \lst@inputlisting}
\newcommand\lst@inputlisting[2][]{%
  \endgroup
  \def\lst@set{#1}%
  \IfFileExists{\lst@inputpath#2}%
  {\expandafter\lst@InputListing\expandafter{\lst@inputpath#2}}%
  {\filename@parse{\lst@inputpath#2}%
   \edef\reserved@a{\noexpand\lst@MissingFileError
       {\filename@area\filename@base}%
       {\ifx\filename@ext\relax tex\else\filename@ext\fi}}%
   \reserved@a}%
  \@doendpe \@newlistfalse \ignorespaces}
%    \end{macrocode}
% We use |\@doendpe| to remove indention at the beginning of the next
%  line---except there is an empty line after |\lstinputlisting|.
% \end{macro}
%
% \begin{macro}{\lst@MissingFileError}
% is a derivation of \LaTeX's |\@missingfileerror|.
%    \begin{macrocode}
\def\lst@MissingFileError#1#2{%
  \typeout{^^J! Package Listings Error: File `#1(.#2)' not found.^^J%
           ^^JType X to quit or <RETURN> to proceed,%
           ^^Jor enter new name. (Default extension: #2)^^J}%
  \message{Enter file name: }%
  {\endlinechar\m@ne \global\read\m@ne to\@gtempa}%
%    \end{macrocode}
% Typing |x| or |X| exits.
%    \begin{macrocode}
  \ifx\@gtempa\@empty \else
    \def\reserved@a{x}\ifx\reserved@a\@gtempa\batchmode\@@end\fi
    \def\reserved@a{X}\ifx\reserved@a\@gtempa\batchmode\@@end\fi
%    \end{macrocode}
% In all other cases we try the new filename.
%    \begin{macrocode}
    \filename@parse\@gtempa
    \edef\filename@ext{\ifx\filename@ext\relax#2\else\filename@ext\fi}%
    \edef\reserved@a{%
      \noexpand\IfFileExists{\filename@area\filename@base.\filename@ext}%
      {\noexpand\lst@InputListing{\filename@area\filename@base.\filename@ext}}%
      {\noexpand\lst@MissingFileError
          {\filename@area\filename@base}{\filename@ext}}}%
    \expandafter\reserved@a
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@InputListing}
% The one and only argument is the filename, but we have the implicit
%  `argument' |\lst@set|.
% Note that |\lst@Init| takes |\relax| as argument.
%    \begin{macrocode}
\def\lst@InputListing#1{%
  \begingroup
  \let\lst@inputfile\@filef@und
  \lsthk@PreSet \gdef\lst@intname{#1}%
  \expandafter\lstsetup\expandafter{\lst@set}%
  \lst@InitDisplay \let\lst@gobble\z@
  \lst@ifprocessdisplay
    \@addtofilelist{#1}%
    \def\lst@next{\everyeof{^^@}%
                  \expandafter\lst@SkipToFirst\@@input\lst@inputfile}%
    \expandafter\lst@next
  \fi
  \lst@ExitDisplay
  \endgroup}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@EndProcessListing}
% This default definition works for |\lstinputlisting|.
%    \begin{macrocode}
\let\lst@EndProcessListing\endinput
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Multiline init and exit}
%
% \begin{lstkey}{aboveskip}
% \begin{lstkey}{belowskip}
% We define and initialize these keys.
%    \begin{macrocode}
\lst@Key{aboveskip}\medskipamount{\def\lst@aboveskip{#1}}
\lst@Key{belowskip}\medskipamount{\def\lst@belowskip{#1}}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
%
% \begin{lstkey}{box}
% This key can be used on individual (multiline) listings only.
%    \begin{macrocode}
\lst@Key{box}{false}[t]{\lstKV@SetIf{#1}\lst@ifbox}
\lst@AddToHook{PreSet}{\let\lst@ifbox\iffalse}
\def\lst@boxtrue{\let\lst@ifbox\iftrue}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lst@InitDisplay}
% If the listing does not float, we might indicate and begin an exact box around
%  the listing or issue |\par|.
%    \begin{macrocode}
\def\lst@InitDisplay{%
  \ifx\lst@float\relax
    \ifhmode\ifinner \lst@boxtrue \else \par \fi\fi
  \fi
  \lst@ifbox
    \expandafter\hbox\expandafter\bgroup\expandafter\lsthk@BoxUnsafe
  \fi
%    \end{macrocode}
% Now we define (and adjust) |\lst@roomleft| and possibly insert the aboveskip.
%    \begin{macrocode}
  \let\lst@roomleft\maxdimen
  \ifx\lst@float\relax
    \ifvmode
      \allowbreak \vskip\lst@aboveskip \goodbreak
      \ifinner\else \def\lst@roomleft{\@colroom-\pagetotal}\fi
    \fi
  \fi
%    \end{macrocode}
% Now we're ready to initialize various data and put the captions/titles into
%  the boxes.
%    \begin{macrocode}
  \normalbaselines
  \lsthk@Init \lsthk@InitVars
  \lsthk@InitVarsDisplay \lsthk@InitDisplay
  \lst@SetTBBox\lst@topbox{\lst@MakeCaption t}%
  \lst@SetTBBox\lst@finalbox{\lst@MakeCaption b}%
  \lst@SetTBBox\lst@botbox{}%
%    \end{macrocode}
% And finally:
%    \begin{macrocode}
  \lst@basicstyle
  \lst@EnterMode{\lst@Pmode}{}%
  \lst@SelectCharTable
  \lsthk@InitVarsBOL\lsthk@InitScanBOL}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@ExitDisplay}
% We output remaining content, insert belowskip if necessary, \ldots
%    \begin{macrocode}
\def\lst@ExitDisplay{%
  \lst@eolistingtrue \lst@OutputTokenStream
  \ifx\lst@float\relax
    \ifvmode
      \goodbreak \vskip\lst@belowskip \allowbreak
    \fi
  \fi
%    \end{macrocode}
% end an open box, and call the hook.
%    \begin{macrocode}
  \lst@ifbox \expandafter\egroup \fi
  \lsthk@ExitDisplay}
%    \end{macrocode}
%    \begin{macrocode}
\lst@AddToHook{ExitDisplay}{}% init
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@SetTBBox}
% An empty box (i.e.~with no height plus depth) is replaced by a void box.
%    \begin{macrocode}
\def\lst@SetTBBox#1#2{%
  \setbox#1\vbox{#2}%
  \ifdim \dimexpr\ht#1+\dp#1=\z@
    \setbox#1\box\voidb@x
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@topbox}
% \begin{macro}{\lst@finalbox}
% \begin{macro}{\lst@botbox}
% These are the boxes for the top, bottom, and final material (i.e.~caption).
%    \begin{macrocode}
\newbox\lst@topbox
\newbox\lst@finalbox
\newbox\lst@botbox
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \subsection{Captions and list of listings}
%
% Axel Sommerfeldt proposed a couple of improvements regarding captions and
%  titles.
% Markus Kohm contributed a much-improved version of |\lstlistoflistings| and
%  \packagename{float} package support.
%
% \begin{lstkey}{listingname}
% \begin{macro}{\lstlistingname}
% The name used for captions.
%    \begin{macrocode}
\lst@Key{listingname}{Listing}{\def\lstlistingname{#1}}
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
%
% \begin{lstkey}{numberby}
% \begin{lstkey}{resetby}
% \begin{lstkey}{numberbychapter}
% \keyname{numberby} checks for the existence of `the counter' and
%  \keyname{resetby} for the reset counter.
%    \begin{macrocode}
\lst@Key{numberby}\relax{%
  \@ifundefined{the#1}{\lst@Error{Undefined \string\the#1}\@eha}%
                      {\def\lst@numberby{#1}%
                       \KV@lst@resetby{#1}}}
\lst@Key{resetby}\relax{%
  \@ifundefined{c@#1}{\lst@Error{Undefined counter #1}\@eha}%
                     {\def\lst@resetby{#1}}}
%    \end{macrocode}
% Utilize \keyname{numberby} and set default behaviour.
%    \begin{macrocode}
\lst@Key{numberbychapter}\relax[t]{%
  \lstKV@SetIf{#1}\lst@if
  \lst@if \KV@lst@numberby{chapter}\else
    \let\lst@numberby\@empty \let\lst@resetby\@empty
  \fi}
%    \end{macrocode}
%    \begin{macrocode}
\@ifundefined{thechapter}{\let\lst@numberby\@empty \let\lst@resetby\@empty}%
                         {\KV@lst@numberby{chapter}}% init
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
%
% \begin{macro}{\thelstlisting}
% \begin{lstkey}{label}
% The counter is allocated |\AtBeginDocument|---or the user couldn't profit from
%  the \keyname{numberby} keys---possibly using a reset counter.
% The definition of |\thelstlisting| might uses the specified parent.
%    \begin{macrocode}
\AtBeginDocument{%
  \ifx\lst@resetby\@empty \newcounter{lstlisting}%
                    \else \newcounter{lstlisting}[\lst@resetby]\fi
  \ifx\lst@numberby\@empty
    \gdef\thelstlisting{\@arabic\c@lstlisting}%
  \else
    \xdef\thelstlisting
      {\noexpand\ifnum\expandafter\noexpand\csname c@\lst@numberby\endcsname>\z@
         \expandafter\noexpand\csname the\lst@numberby\endcsname.%
       \noexpand\fi
       \noexpand\@arabic\noexpand\c@lstlisting}%
  \fi
%    \end{macrocode}
% Deactivate the keys.
%    \begin{macrocode}
  \let\lst@numberby\@empty \let\lst@resetby\@empty
  \let\KV@lst@numberby\@gobble \let\KV@lst@resetby\@gobble}
%    \end{macrocode}
% We |\refstepcounter| the listing counter if |\lst@@caption| is not empty.
% Otherwise we ensure correct hyper-references, see below.
%    \begin{macrocode}
\lst@AddToHook{InitDisplay}%
  {\ifx\lst@@caption\@empty\expandafter\lst@HRefStepCounter \else
                           \expandafter\refstepcounter
   \fi {lstlisting}%
   \ifx\lst@label\@empty\else \label{\lst@label}\fi}
%    \end{macrocode}
%    \begin{macrocode}
\lst@Key{label}{}{\def\lst@label{#1}}
%    \end{macrocode}
% \end{lstkey}
% \end{macro}
%
% \begin{macro}{\lst@HRefStepCounter}
% This macro sets the listing number to a negative value since the user
%  shouldn't reference such a listing.
% If the \packagename{hyperref} package is present, we use `lstlisting'
%  (the argument from above) to hyperref to.
% The groups have been added to prevent other packages (namely
%  \packagename{tabularx}) from reading the locally changed counter
%  and writing it back globally.
%    \begin{macrocode}
\def\lst@HRefStepCounter#1{%
  \begingroup
  \c@lstlisting\lst@neglisting
  \advance\c@lstlisting\m@ne \xdef\lst@neglisting{\the\c@lstlisting}%
  \ifx\hyper@refstepcounter\@undefined\else
    \hyper@refstepcounter{#1}%
  \fi
  \endgroup}
\gdef\lst@neglisting{\z@}% init
%    \end{macrocode}
% \end{macro}
%
% \begin{lstkey}{abovecaptionskip}
% \begin{lstkey}{belowcaptionskip}
% Axel proposed to separate the allocation of the skip registers from the
%  default definition of |\@makecaption|.
%    \begin{macrocode}
\@ifundefined{abovecaptionskip}%
{\newskip\abovecaptionskip
 \newskip\belowcaptionskip}{}%
%    \end{macrocode}
% The user defined values are assigned to the skip registers before the first
%  chunk of a listing is output.
%    \begin{macrocode}
\lst@Key{abovecaptionskip}\smallskipamount{\def\lst@abovecaption{#1}}
\lst@Key{belowcaptionskip}\smallskipamount{\def\lst@belowcaption{#1}}
\lst@AddToHook{InitDisplay}%
  {\abovecaptionskip\lst@abovecaption\relax
   \belowcaptionskip\lst@belowcaption\relax}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
%
% \begin{lstkey}{title}
% \begin{lstkey}{caption}
% \begin{lstkey}{captionpos}
% These keys mainly store their arguments.
%    \begin{macrocode}
\lst@Key{title}\relax{%
  \def\lst@title{#1}\let\lst@caption\relax \let\lst@@caption\@empty}
\lst@Key{caption}{}{\lstKV@OArg[{#1}]{#1}%
  {\def\lst@caption{##2}\def\lst@@caption{##1}}%
   \let\lst@title\@empty}
\lst@Key{captionpos}{t}{\def\lst@captionpos{#1}}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
%
% \begin{macro}{\lst@MakeCaption}
% First we provide |\@makecaption|, which is an exact copy of the definition in
%  the article class.
% To respect the LPPL: You should have a copy of this class on your \TeX\ system
%  or you can obtain a copy from the CTAN.
%    \begin{macrocode}
\@ifundefined{@makecaption}
{\long\def\@makecaption#1#2{%
   \vskip\abovecaptionskip
   \sbox\@tempboxa{#1: #2}%
   \ifdim \wd\@tempboxa >\hsize
     #1: #2\par
   \else
     \global \@minipagefalse
     \hb@xt@\hsize{\hfil\box\@tempboxa\hfil}%
   \fi
   \vskip\belowcaptionskip}%
}{}
%    \end{macrocode}
% The introduction of |\fnum@lstlisting| is also due to Axel.
%    \begin{macrocode}
\def\fnum@lstlisting{%
  \lstlistingname
  \ifx\lst@@caption\@empty\else~\thelstlisting\fi}%
%    \end{macrocode}
% We make a caption if and only if the caption is not empty and the user
%  requested a caption at |#1| $\in\{\mathtt t,\mathtt b\}$.
% The |\ignorespaces| in the |\@makecaption| call is added to match what
%  \LaTeX\ does in |\@caption|; the AMSbook class (and perhaps others) assume
%  this is present and attempt to strip it off when testing for an empty
%  caption, causing a bug noted by Xiaobo Peng.
%    \begin{macrocode}
\def\lst@MakeCaption#1{%
  \ifx\lst@caption\@empty\else
    \lst@IfSubstring #1\lst@captionpos
    {\par\@parboxrestore\normalsize\normalfont % \noindent (AS)
     \vbox{\ifx\lst@title\@empty
             \lst@makecaption\fnum@lstlisting{\ignorespaces \lst@caption}
           \else
             \lst@maketitle\lst@title % (AS)
           \fi}}%
    {}%
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lst@makecaption}
% \begin{macro}{\lst@maketitle}
% Axel proposed the first definition.
% The other two are default definitions.
% They may be adjusted to make \packagename{listings} compatible with other
%  packages and classes.
%    \begin{macrocode}
\def\lst@makecaption{\@makecaption}
\def\lst@maketitle{\@makecaption\lst@title@dropdelim}
\def\lst@title@dropdelim#1{\ignorespaces}
%    \end{macrocode}
% Axel provided the following \packagename{caption}(\packagename{2}) support.
%    \begin{macrocode}
\AtBeginDocument{%
\@ifundefined{captionlabelfalse}{}{%
  \def\lst@maketitle{\captionlabelfalse\@makecaption\@empty}}%
\@ifundefined{caption@startrue}{}{%
  \def\lst@maketitle{\caption@startrue\@makecaption\@empty}}%
}
%    \end{macrocode}
% \end{macro}\end{macro}
%
% \begin{lstkey}{name}
% \begin{macro}{\lstname}
% \begin{macro}{\lst@name}
% \begin{macro}{\lst@intname}
% The internal name for multi-line listings is reset by all such pretty-printing
%  commands, can be set by the user, and is converted to a printable form.
%    \begin{macrocode}
\lst@Key{name}\relax{\def\lst@intname{#1}}
\lst@AddToHook{PreSet}{\global\let\lst@intname\@empty}
\lst@AddToHook{InitDisplay}%
  {\let\lst@arg\lst@intname \lst@ReplaceIn\lst@arg\lst@filenamerpl
   \global\let\lst@name\lst@arg \global\let\lstname\lst@name}
%    \end{macrocode}
% |\lst@ReplaceIn| replaces characters, which are not directly printable.
%    \begin{macrocode}
\def\lst@filenamerpl{_\textunderscore $\textdollar -\textendash}
\global\let\lst@intname\@empty % init
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{lstkey}
%
% \begin{lstkey}{listlistingname}
% \begin{macro}{\lstlistlistingname}
% sets respectively contains the header name for the list of listings.
%    \begin{macrocode}
\lst@Key{listlistingname}{Listings}{\def\lstlistlistingname{#1}}
%    \end{macrocode}
% \end{macro}
% \end{lstkey}
%
% \begin{lstkey}{nolol}
% is just a key, but we also define |\lst@nololtrue| to change the setting for
%  listings without captions.
%    \begin{macrocode}
\lst@Key{nolol}{false}[t]{\lstKV@SetIf{#1}\lst@ifnolol}
\def\lst@nololtrue{\let\lst@ifnolol\iftrue}
\let\lst@ifnolol\iffalse % init
%    \end{macrocode}
% We make a `lol' entry if the name is neither empty nor a single space.
% But we test |\lst@|(|@|)|caption| and |\lst@ifnolol| first.
%    \begin{macrocode}
\lst@AddToHook{InitDisplay}%
  {\lst@ifnolol\else
     \ifx\lst@@caption\@empty
       \ifx\lst@caption\@empty
         \ifx\lst@intname\@empty\else \def\lst@temp{ }%
         \ifx\lst@intname\lst@temp\else
           \addcontentsline{lol}{lstlisting}\lst@name
         \fi\fi
       \fi
     \else
       \addcontentsline{lol}{lstlisting}%
           {\protect\numberline{\thelstlisting}\lst@@caption}%
     \fi
   \fi}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\l@lstlisting}
% prints one `lol' line.
%    \begin{macrocode}
\def\l@lstlisting#1#2{\@dottedtocline{1}{1.5em}{2.3em}{#1}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lstlistoflistings}
% The default makes an adjustment of |\@starttoc| and calls |\tableofcontents|.
% This way, redefinitions of that macro (e.g.~without any |\MakeUppercase|
%  inside) also take effect on the list of listings.
%    \begin{macrocode}
\lst@UserCommand\lstlistoflistings{\bgroup
    \let\contentsname\lstlistlistingname
    \let\lst@temp\@starttoc \def\@starttoc##1{\lst@temp{lol}}%
    \tableofcontents \egroup}
%    \end{macrocode}
% The following few comments are from Markus.
%
% Make use of |\float@listhead| if defined (e.g. using float or KOMA-Script)
%    \begin{macrocode}
\@ifundefined{float@listhead}{}{%
  \renewcommand*{\lstlistoflistings}{%
    \begingroup
%    \end{macrocode}
% Switch to one-column mode if the switch for switching is available.
%    \begin{macrocode}
      \@ifundefined{@restonecoltrue}{}{%
        \if@twocolumn
          \@restonecoltrue\onecolumn
        \else
          \@restonecolfalse
        \fi
      }%
      \float@listhead{\lstlistlistingname}%
%    \end{macrocode}
% Set |\parskip| to 0pt (should be!), |\parindent| to 0pt (better but not always
%  needed), |\parfillskip| to 0pt plus 1fil (should be!).
%    \begin{macrocode}
      \parskip\z@\parindent\z@\parfillskip \z@ \@plus 1fil%
      \@starttoc{lol}%
%    \end{macrocode}
% Switch back to twocolumn (see above).
%    \begin{macrocode}
      \@ifundefined{@restonecoltrue}{}{%
        \if@restonecol\twocolumn\fi
      }%
    \endgroup
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\float@addtolists}
% The \packagename{float} package defines a generic way for packages to add
%  things (such as chapter names) to all of the lists of floats other than the
%  standard figure and table lists.
% Each package that defines a list of floats adds a command to
%  |\float@addtolists|, and then packages (such as the KOMA-script document
%  classes) which wish to add things to all lists of floats can then use it,
%  without needing to be aware of all of the possible lists that could exist.
% Thanks to Markus Kohm for the suggestion.
%
% Unfortunately, \packagename{float} defines this with |\newcommand|; thus, to
%  avoid conflict, we have to redefine it after \packagename{float} is loaded.
% |\AtBeginDocument| is the easiest way to do this.
% Again, thanks to Markus for the advice.
%    \begin{macrocode}
\AtBeginDocument{%
  \@ifundefined{float@addtolists}%
    {\gdef\float@addtolists#1{\addtocontents{lol}{#1}}}%
    {\let\orig@float@addtolists\float@addtolists
     \gdef\float@addtolists#1{%
       \addtocontents{lol}{#1}%
       \orig@float@addtolists{#1}}}%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Interface to \textsf{fancyvrb}}
%
% \begin{lstkey}{fancyvrb}
% The key sets the boolean and call a submacro, \ldots
%    \begin{macrocode}
\lst@Key{fancyvrb}\relax[t]{%
  \lstKV@SetIf{#1}\lst@iffancyvrb
  \lst@Fancyvrb}
%    \end{macrocode}
% which, if not already present, loads the \aspectname{fancyvrb} aspect.
%    \begin{macrocode}
\ifx\lst@Fancyvrb\@undefined
  \gdef\lst@Fancyvrb{\lst@RequireAspects{fancyvrb}\lst@Fancyvrb}
\fi
%    \end{macrocode}
% \end{lstkey}
%
%
% \subsection{Compatibility and temporary definitions}
%
% \begin{lstkey}{extendedchars}
% The new scanning engine makes this key completely obsolet.
%    \begin{macrocode}
\lst@Key{extendedchars}\relax[t]{}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{lstkey}{alsoletter}
% \begin{lstkey}{alsodigit}
% \begin{lstkey}{alsoother}
% These keys are defined in terms of \keyname{morecharclass}.
%    \begin{macrocode}
\lst@Key{alsoletter}\relax{\KV@lst@morecharclass{[i]#1}}
\lst@Key{alsodigit}\relax{\KV@lst@morecharclass{[d]#1}}
\lst@Key{alsoother}\relax{\KV@lst@morecharclass{[m]#1}}
%    \end{macrocode}
% \end{lstkey}
% \end{lstkey}
% \end{lstkey}
%
% \begin{lstkey}{showtokens}
% If active we put a box around each output unit.
%    \begin{macrocode}
\lst@Key{showtokens}{false}[t]{\lstKV@SetIf{#1}\lst@ifshowtokens}
\lst@AddToHook{Init}{%
  \lst@ifshowtokens
    \fboxsep\z@ \let\lst@alloverstyle\lst@showtokens
  \fi}
\def\lst@showtokens#1{\fbox{\strut#1}}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{lstkey}{literate}
% We load the required aspect if necessary and delete all previous
%  transcriptions.
%    \begin{macrocode}
\lst@Key{literate}\relax{%
  \ifx\KV@lst@transcribe\lst@undefined \lst@RequireAspects{transcribe}\fi
  \KV@lst@transcribe{}%
  \lst@Literate#1{}\relax\z@}
%    \end{macrocode}
% We iterate down the list and give each item to \keyname{moretranscribe}.
%    \begin{macrocode}
\def\lst@Literate#1#2#3{%
  \ifx\relax#2\@empty\else
    \KV@lst@moretranscribe{{#1}{#2}{#3}}%
    \expandafter\lst@Literate
  \fi}
%    \end{macrocode}
% \end{lstkey}
%
% \begin{macro}{\lstset}
% For the moment |\lstset| is equivalent to |\lstsetup|.
%    \begin{macrocode}
\let\lstset\lstsetup
%    \end{macrocode}
% \end{macro}
%
% One option has no function anymore---except giving a warning.
%    \begin{macrocode}
\DeclareOption{savemem}
  {\PackageWarning{Listings}{Option `savemem' is not available anymore}}
%    \end{macrocode}
%
%
% \section{Epilogue}
%
%    \begin{macrocode}
%<*info>
\lst@Info\@ne{kernel loaded}
%</info>
%    \end{macrocode}
% We have three more explicitly specified options.
% Two just set an internal switch.
%    \begin{macrocode}
\DeclareOption{draft}{\let\lst@ifprocessdisplay\iffalse}
\DeclareOption{final}{\let\lst@ifprocessdisplay\iftrue}
%    \end{macrocode}
% The third clears the data macro used right now.
%    \begin{macrocode}
\DeclareOption{noaspects}{\let\lst@loadaspects\@empty}
%    \end{macrocode}
% All other options add the (aspect) name to |\lst@loadaspects| or remove it
%  from that data macro.
%    \begin{macrocode}
\DeclareOption*{\expandafter\lst@ProcessOption\CurrentOption\relax}
\def\lst@ProcessOption#1#2\relax{%
  \ifx #1!%
    \lst@RemoveFromList\lst@loadaspects{#2}%
  \else
    \lst@lAddTo\lst@loadaspects{,#1#2}%
  \fi}
%    \end{macrocode}
% The default list of loaded aspects is defined only if it's undefined yet and
%  the definition depends on the loaded key\(=\)value package.
%    \begin{macrocode}
\@ifundefined{lst@loadaspects}
{\@ifpackageloaded{xkeyval}%
 {\def\lst@loadaspects{style,language}}% TODO: load strings,comments,keywords?
 {\def\lst@loadaspects{strings,comments,keywords,emph,index,escape,%
      style,language,frames}}%
}{}
%    \end{macrocode}
% We load the patch file, process the options, \ldots
%    \begin{macrocode}
\InputIfFileExists{lst2patch.sty}{%
%<*info>
\lst@Info\@ne{applying patch file}
%</info>
}{}
%<*info>
\lst@Info\@ne{processing options}
%</info>
\ProcessOptions
%    \end{macrocode}
% and load the aspects.
%    \begin{macrocode}
\lst@RequireAspects\lst@loadaspects
\let\lst@loadaspects\@empty
%    \end{macrocode}
% If present we select the empty style and language.
%    \begin{macrocode}
\lst@UseHook{SetStyle}\lst@UseHook{EmptyStyle}
\lst@UseHook{SetLanguage}\lst@UseHook{EmptyLanguage}
%    \end{macrocode}
% Finally we load the configuration files \ldots
%    \begin{macrocode}
%<*info>
\lst@Info\@ne{loading and applying configuration}
%</info>
\InputIfFileExists{listings2.cfg}{}{}
\InputIfFileExists{lstlocal2.cfg}{}{}
%    \end{macrocode}
% and execute the code for each loaded aspect.
%    \begin{macrocode}
\lst@for\lst@loadedaspects\do
{\ifcsname lstconfig@#1\endcsname
   \csname lstconfig@#1\endcsname
   \global\expandafter\let\csname lstconfig@#1\endcsname\lst@undefined
 \fi}
%    \end{macrocode}
%
%    \begin{macrocode}
%<*info>
\lst@ReportAllocs
%</info>
%</kernel>
%    \end{macrocode}
%
%
\endinput
